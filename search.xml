<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[xml(三)]]></title>
    <url>%2F%2F2019%2F07%2F23%2Fxml-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[friendships XSL转换XSL转换（XSLT）机制可是指定将XML文档转换为其他格式的规则，例如，纯文本、XHTML或其他任何XML格式。XSLT通常用来将一个机器可读的XML格式转译为另一种机器可读的XML格式，或者将XML转译为适于人类阅读的标识格式 你需要提供XSLT样式表，它描述了XML文档向某种其他格式转换的规则。XSLT处理器处理这个文档，并产生想要的输出 加入我们想要把下面这个XML文件： 123456789101112&lt;staff&gt; &lt;employee&gt; &lt;name&gt;Carl Cracker&lt;/name&gt; &lt;salary&gt;75000&lt;/salary&gt; &lt;hiredate year="1987" month="12" day="15" /&gt; &lt;/employee&gt; &lt;employee&gt; &lt;name&gt;Harry Hacker&lt;/name&gt; &lt;salary&gt;50000&lt;/salary&gt; &lt;hiredate year="1989" month="3" day="1" /&gt; &lt;/employee&gt;&lt;/staff&gt; 转换成下面的表格： 12345678&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;Carl Cracker&lt;/td&gt;&lt;td&gt;$75000&lt;/td&gt;&lt;td&gt;1987-12-15&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Harry Hacker&lt;/td&gt;&lt;td&gt;$50000&lt;/td&gt;&lt;td&gt;1989-3-1&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 具有转换模板的样式表形式如下： 12345678&lt;?xml version="1.0" encoding="utf-8"&gt;&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt; &lt;xsl:output method="html"/&gt; template1 template2&lt;/xsl:stylesheet&gt; 上例的输出设定为html，还可以设置为xml和text 下面是个典型的模板，match属性的值是一个XPath表达式。该模板表名，每当看到一个XPath集/staff/employee中的一个节点时，做以下动作： 产生字符串&lt; tr&gt; 对于要处理的子元素继续应用模板。 当处理完所有子元素后，产生字符串&lt; /tr&gt; 123&lt;xsl:template match="/staff/employee"&gt; &lt;tr&gt;&lt;xsl:apply-templates/&gt;&lt;/tr&gt;&lt;/xsl:template&gt; XSLT处理器由检查根元素开始其处理过程。每当一个节点匹配某个模板时，就回应应用这个模板（如果匹配多个，就会使用最佳匹配的那个）。如果没有匹配的模板，处理器就执行默认操作。对于文本节点，默认操作是把它的内容包含到输出中去。对于元素，默认操作是不产生输出的，但会继续处理其子节点。 如果想把属性值复制到输出中去，就不得不再做稍微复杂点的操作了。下面是一个例子，当处理hiredate节点时。该模板会产生： 字符串&lt; td&gt; year属性的值 一个连字符 month属性的值 一个连字符 day属性值 一个连字符 字符串&lt; /td&gt; xsl:value-of语句用于计算节点集的字符串值。节点集由select属性的XPath值设定。 123&lt;xsl:template match="/staff/employee/hiredate"&gt; &lt;td&gt;&lt;xsl:value-of select="@year"/&gt;-&lt;xsl:value-of select="@month"/&gt;-&lt;xsl:value-of select="@day"/&gt;&lt;/td&gt;&lt;/xsl:template&gt;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java访问控制]]></title>
    <url>%2F%2F2019%2F07%2F23%2Fjava%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[java所有的的访问修饰符控制的都是直接访问]]></content>
      <categories>
        <category>我眼中的java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[static关键字的使用(一)]]></title>
    <url>%2F%2F2019%2F07%2F23%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[static方法与构造静态方法一般不能调用任何非静态成员，却能调用非静态的构造 12345678910111213141516171819202122232425262728293031323334353637383940414243package staticmethod;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub StaticMethod aMethod=StaticMethod.newInstance(); System.out.println(aMethod); &#125;&#125;class StaticMethod&#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public static StaticMethod newInstance()&#123; return new StaticMethod(1, "hhh"); &#125; private StaticMethod()&#123; &#125; @Override public String toString() &#123; return "StaticMethod [id=" + id + ", name=" + name + "]"; &#125; private StaticMethod(int id, String name) &#123; super(); this.id = id; this.name = name; &#125;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>对象与类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xml(二)]]></title>
    <url>%2F%2F2019%2F07%2F23%2Fxml-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[刚刚好——薛之谦 StAX解析器StAX解析器是一种“拉解析器（pull parser）”，与安装事件处理器不同，你只需要使用下面的基本循环来迭代所有事件： 1234567InputStream in = url.openStream();XMLInputFactory factory=XMLInputFactory.newInstance();XMLStreamReader parser=factory.createXMLStreamReader(in);wehile(parser.hasNext())&#123; int event =parser.next(); Call parser methods to obtain event details&#125; 例如，在解析下面的片段时 1234&lt;font&gt; &lt;name&gt;Helvetica&lt;/name&gt; &lt;size units="pt"&gt;78&lt;/size&gt;&lt;/font&gt; 解析器将产生下面的事件： START_ELEMENT,元素名：font CHARACTERS，内容：空白字符 START_ELEMENT，元素名：name CHARACTERS，内容：Helvetica END_ELEMENT，元素名：name CHARACTERS，内容：空白字符 START_ELEMENT，元素名：size CHARACTERS，内容：78 END_ELEMENT，元素名：size CHARACTERS，内容：空白字符 END_ELEMENT，元素名：font 默认情况下命名空间是使能的，你可以通过修改下面的工厂来使其无效： 1factory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE,false); 示例程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041package staxtest;import java.io.InputStream;import java.net.URL;import javax.xml.stream.XMLInputFactory;import javax.xml.stream.XMLStreamConstants;import javax.xml.stream.XMLStreamReader;public class StAXTest&#123; public static void main(String[] args) throws Exception &#123; String urlString; if (args.length == 0) &#123; urlString = "https://bigengzhe.github.io/atom.xml"; System.out.println("Using " + urlString); &#125; else urlString = args[0]; URL url = new URL(urlString); InputStream in = url.openStream();//用URL来初始化一个输入流 XMLInputFactory factory = XMLInputFactory.newInstance(); XMLStreamReader parser = factory.createXMLStreamReader(in);//用输入流来初始化解析器 while (parser.hasNext()) &#123; int event = parser.next();//返回的常量代表相应的解析事件， if (event == XMLStreamConstants.START_ELEMENT) &#123; if (parser.getLocalName().equals("link")) &#123; String href = parser.getAttributeValue(null, "href"); //当前事件是START_ELEMENT时，获取给定属性的值。 //若第一个参数为空，则不检查命名空间 if (href != null) System.out.println(href); &#125; &#125; &#125; &#125;&#125; 结果截图： 生成XML文档​ 现在你已经知道怎样编写读取XML的java程序了，下面让我们开始介绍他的反向过程。当然你可以选择直接通过一系列print调用，打印出各元素，属性和文本内容来编写XML文件，但其实有更好的办法。 DOM/XSLT方式可以使用文档的内容构建一棵DOM树，然后写出该树的所有内容。步骤如下： 通过调用DocumentBuilder类的newDocument方法得到一个空文档 1Document doc = builder.newDocument(); 使用Document类的createElement可以构建文档里的元素 12 Element rootElement= doc.createElement(rootName);Element childElement=doc.createElement(childName); 使用createTextNode方法可以构建文本节点 1Text textNode=doc.createTextNode(textcontents); 使用以下方法可以给文档加上根元素，给父元素加上子节点 123doc.appendChild(rootElement);rootElement.appendChild(childElement);childElement.appendChild(textNode); 如果要设置元素属性的话： 1rootElement.setAttribute(name,value); 使用XSTL将DOM树写入到输出流： 123456789File f = chooser.getSelectedFile();//得到输出流目标目标文件Transformer t = TransformerFactory.newInstance().newTransformer();t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, "http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd");t.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "-//W3C//DTD SVG 20000802//EN");t.setOutputProperty(OutputKeys.INDENT, "yes");t.setOutputProperty(OutputKeys.METHOD, "xml");t.setOutputProperty("&#123;http://xml.apache.org/xslt&#125;indent-amount", "2");t.transform(new DOMSource(doc), new StreamResult(new FileOutputStream(f))); 使用StAX写XML文档SaAX API使我们可以直接将XML树写出，不用构建DOM树，这需要从某个OutputStream中构建一个XMLstreamWriter。步骤如下 先得到一个XMLstreamWriter对象 12XMLOutputFactory factory=XMLOutputFactory.newInstance();XMLStreamWriter writer=factory.createXMLStreamWriter(out);//out是个输出流对象 产生XML文件头 1writer.writeStartDocument(); 添加元素 1writer.writeStartElement(name); 添加属性 1writer.writeAttribute(name,value); 现在，可以再次通过第三步来添加新的子节点，或者通过下面的语句写出字符 1writer.writeCharacters(text); 在添加完所有的子节点后，调用下面的方法会使当前元素被关闭 1writer.writeEndElement(); 写出没有子节点的元素（如：&lt; img …/&gt;)，可以使用下面的调用 1writer.writeEmptyElement(name); 最后在文档的结尾调用： 1writer.writeEndDocument(); 与使用DOM/XSLT方式一样，我们不必担心属性值和字符数据中的转义字符，但是，我们仍旧有可能会产生非良构的XML，例如具有多个根节点的文档。并且，StAX当前的版本还没有任何对产生缩进输出的支持 示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304package xmlwritetest;import java.awt.Color;import java.awt.EventQueue;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Rectangle;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.geom.Rectangle2D;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.Random;import javax.swing.JComponent;import javax.swing.JFileChooser;import javax.swing.JFrame;import javax.swing.JMenu;import javax.swing.JMenuBar;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.stream.XMLOutputFactory;import javax.xml.stream.XMLStreamException;import javax.xml.stream.XMLStreamWriter;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import org.w3c.dom.Document;import org.w3c.dom.Element;public class XMLWriteTest&#123; public static void main(String[] args) &#123; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; XMLWriteFrame frame = new XMLWriteFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); &#125; &#125;); &#125;&#125;/** * A frame with a component for showing a modern drawing. */class XMLWriteFrame extends JFrame&#123; public XMLWriteFrame() &#123; setTitle("XMLWriteTest"); setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT); chooser = new JFileChooser(); // add component to frame comp = new RectangleComponent(); add(comp); // set up menu bar JMenuBar menuBar = new JMenuBar(); setJMenuBar(menuBar); JMenu menu = new JMenu("File"); menuBar.add(menu); JMenuItem newItem = new JMenuItem("New"); menu.add(newItem); newItem.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; comp.newDrawing(); &#125; &#125;); JMenuItem saveItem = new JMenuItem("Save with DOM/XSLT"); menu.add(saveItem); saveItem.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; try &#123; saveDocument(); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(XMLWriteFrame.this, e.toString()); &#125; &#125; &#125;); JMenuItem saveStAXItem = new JMenuItem("Save with StAX"); menu.add(saveStAXItem); saveStAXItem.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; try &#123; saveStAX(); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(XMLWriteFrame.this, e.toString()); &#125; &#125; &#125;); JMenuItem exitItem = new JMenuItem("Exit"); menu.add(exitItem); exitItem.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; System.exit(0); &#125; &#125;); &#125; /** * Saves the drawing in SVG format, using DOM/XSLT */ public void saveDocument() throws TransformerException, IOException &#123; if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) return; File f = chooser.getSelectedFile(); Document doc = comp.buildDocument(); Transformer t = TransformerFactory.newInstance().newTransformer(); t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, "http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd"); t.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "-//W3C//DTD SVG 20000802//EN"); t.setOutputProperty(OutputKeys.INDENT, "yes"); t.setOutputProperty(OutputKeys.METHOD, "xml"); t.setOutputProperty("&#123;http://xml.apache.org/xslt&#125;indent-amount", "2"); t.transform(new DOMSource(doc), new StreamResult(new FileOutputStream(f))); &#125; /** * Saves the drawing in SVG format, using StAX */ public void saveStAX() throws FileNotFoundException, XMLStreamException &#123; if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) return; File f = chooser.getSelectedFile(); XMLOutputFactory factory = XMLOutputFactory.newInstance(); XMLStreamWriter writer = factory.createXMLStreamWriter(new FileOutputStream(f)); comp.writeDocument(writer); writer.close(); &#125; public static final int DEFAULT_WIDTH = 300; public static final int DEFAULT_HEIGHT = 200; private RectangleComponent comp; private JFileChooser chooser;&#125;/** * A component that shows a set of colored rectangles */class RectangleComponent extends JComponent&#123; public RectangleComponent() &#123; rects = new ArrayList&lt;Rectangle2D&gt;(); colors = new ArrayList&lt;Color&gt;(); generator = new Random(); DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try &#123; builder = factory.newDocumentBuilder(); &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; &#125; /** * Create a new random drawing. */ public void newDrawing() &#123; int n = 10 + generator.nextInt(20); rects.clear(); colors.clear(); for (int i = 1; i &lt;= n; i++) &#123; int x = generator.nextInt(getWidth()); int y = generator.nextInt(getHeight()); int width = generator.nextInt(getWidth() - x); int height = generator.nextInt(getHeight() - y); rects.add(new Rectangle(x, y, width, height)); int r = generator.nextInt(256); int g = generator.nextInt(256); int b = generator.nextInt(256); colors.add(new Color(r, g, b)); &#125; repaint(); &#125; public void paintComponent(Graphics g) &#123; if (rects.size() == 0) newDrawing(); Graphics2D g2 = (Graphics2D) g; // draw all rectangles for (int i = 0; i &lt; rects.size(); i++) &#123; g2.setPaint(colors.get(i)); g2.fill(rects.get(i)); &#125; &#125; /** * Creates an SVG document of the current drawing. * @return the DOM tree of the SVG document */ public Document buildDocument() &#123; Document doc = builder.newDocument(); Element svgElement = doc.createElement("svg"); doc.appendChild(svgElement); svgElement.setAttribute("width", "" + getWidth()); svgElement.setAttribute("height", "" + getHeight()); for (int i = 0; i &lt; rects.size(); i++) &#123; Color c = colors.get(i); Rectangle2D r = rects.get(i); Element rectElement = doc.createElement("rect"); rectElement.setAttribute("x", "" + r.getX()); rectElement.setAttribute("y", "" + r.getY()); rectElement.setAttribute("width", "" + r.getWidth()); rectElement.setAttribute("height", "" + r.getHeight()); rectElement.setAttribute("fill", colorToString(c)); svgElement.appendChild(rectElement); &#125; return doc; &#125; /** * Writers an SVG document of the current drawing. * @param writer the document destination */ public void writeDocument(XMLStreamWriter writer) throws XMLStreamException &#123; writer.writeStartDocument(); writer.writeDTD("&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 20000802//EN\" " + "\"http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd\"&gt;"); writer.writeStartElement("svg"); writer.writeAttribute("width", "" + getWidth()); writer.writeAttribute("height", "" + getHeight()); for (int i = 0; i &lt; rects.size(); i++) &#123; Color c = colors.get(i); Rectangle2D r = rects.get(i); writer.writeEmptyElement("rect"); writer.writeAttribute("x", "" + r.getX()); writer.writeAttribute("y", "" + r.getY()); writer.writeAttribute("width", "" + r.getWidth()); writer.writeAttribute("height", "" + r.getHeight()); writer.writeAttribute("fill", colorToString(c)); &#125; writer.writeEndDocument(); // closes svg element &#125; /** * Converts a color to a hex value. * @param c a color * @return a string of the form #rrggbb */ private static String colorToString(Color c) &#123; StringBuffer buffer = new StringBuffer(); buffer.append(Integer.toHexString(c.getRGB() &amp; 0xFFFFFF)); while (buffer.length() &lt; 6) buffer.insert(0, '0'); buffer.insert(0, '#'); return buffer.toString(); &#125; private ArrayList&lt;Rectangle2D&gt; rects; private ArrayList&lt;Color&gt; colors; private Random generator; private DocumentBuilder builder;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XPath]]></title>
    <url>%2F%2F2019%2F07%2F22%2FXPath%2F</url>
    <content type="text"><![CDATA[缘分一道桥 如果要定位某个XML文档中的一段特定信息，DOM解析方式过于麻烦，此时可用XPath XPath可以描述XML文档中的一组节点 例如: /gridbag/row 描述了根元素gridbag的子元素中所有的row元素。 可以用[]操作符来选择特定元素：/gridbag/row[1] 这表示的是第一行（索引号从1开始）。 使用@操作符可以得到属性值。 XPath表达式：/gridbag/row[1]/cell[1]/@anchor 描述了第一行第一个单元格的anchor属性。 XPath表达式：/gridbag/row/cell/@anchor 描述了作为根元素gridbag子元素的那些行元素中所有单元格的anchor属性节点。 以下是代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243package xpath;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.xpath.XPath;import javax.xml.xpath.XPathConstants;import javax.xml.xpath.XPathFactory;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;public class Main &#123; public static void main(String[] args) throws Exception&#123; // TODO Auto-generated method stub File f=new File("fontdialog.xml"); DocumentBuilderFactory dfactory=DocumentBuilderFactory.newInstance();//DocumentBuilderFactory实例化 DocumentBuilder builder=dfactory.newDocumentBuilder(); Document doc=builder.parse(f);//用DOM方式指定XML文档对象 XPathFactory factory=XPathFactory.newInstance(); XPath path=factory.newXPath(); NodeList nodes=(NodeList)path.evaluate("/gridbag/row", doc,XPathConstants.NODESET);//获取/gridbag/row所有元素 System.out.println(nodes.getLength()); System.out.println((Number)path .evaluate("count(/gridbag/row)", doc, XPathConstants.NUMBER));//计算row节点的数量，注意row后面不要带斜杠 Node node=(Node)path.evaluate("/gridbag/row[1]/cell[1]/bean/class", doc,XPathConstants.NODE);//获取特定子元素 String author=(String)path.evaluate("/gridbag/row[1]/cell[1]/@anchor", doc);//获取特定元素属性值 System.out.println(node.getNodeName()); System.out.println(author); Node node1=(Node)path.evaluate("/gridbag/row[1]", doc,XPathConstants.NODE);//获取特定子元素 String node2=path.evaluate("/row/cell[1]/@author", node1); System.out.println("从任意一个节点开始,如"+node1.getNodeName()+"结果："+node2);//测试失败！！ &#125;&#125; 输出结果： 意外情况（方法已过时）： 感觉xml相关类及接口置放位置很是混乱：]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[致自己]]></title>
    <url>%2F%2F2019%2F07%2F22%2F%E8%87%B4%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[水星记——郭顶： ​ 这些天晚上在看谷川俊太郎的《一个人生活》，感触很多。谷川俊太郎是日本著名的诗人和散文家，这本书是他在年近古稀之时写的一个散文集，写的朴实随意，却又不失有趣。 ​ 其中《翘望春天的书信》篇中引用的永赖清子的的一首诗给了我极其深刻的印象： 一直在原野之上 因我一直急于求成 致使其他毫无建树 我为了什么而如此地心急火燎呢？ 思虑再三&nbsp;&nbsp;&nbsp;&nbsp;我只是急着规划自己成长的脚步 ——明明那脚步永不会停歇—— 而且，明明只会让我舍弃很多很多的美好——​ 那么我急于求成了吗？大概是有的吧，俩三月内要看完很多书，还有很多视频要看，因此顾此失彼，荒了很多其他自己曾经立志要坚持的东西，可是还能怎么办呢，马上要开始秋招了，那些东西是找到一个好的实习所必备的知识。同学们都打算考研，在努力备战。比起有人说考研是一个人的修行，现在来说却是用在我身上更为合适。凯歌不在这已经好几天了，从早到晚都是一个人，果然一个人的生活。 ​ 说起来这两天学习有点松懈，总是不想学习，内心给了自己一个寻找自我的借口不断放纵，安逸是毁灭的前兆，坚持努力吧，趁自己还有充裕的时间，趁自己还没有被其他琐事所烦扰，仔细一想，这不就是我租房的意义所在？如果不想开学后一无所获，不想承受家里的压力，自己给姐姐和父母许下的承诺，Keep fighting。开学后就要写实训课的设计了，开学前还要花点时间想想写啥以及如何写的问题，自己还想想在项目里用上框架啥的，不知是否现实（目测应该可以），等等，我突然有个大胆的想法，要是把我的个人博客写成一个设计岂不两全其美（窃喜），哈哈哈哈。 用户访问网站要先要求登录或注册，之后用其用户id实例化一个hexo项目文件夹； 利用java更改其配置文件（直接copy效果更好）； 用户写博客的话可以直接上传Markdown文件，然后服务器加载其文件，重新生成相应文件 增加点赞和取消点赞功能 增加评论和删除评论功能 增加搜索文章（仅限标题）功能 可达鸭眉头一挑，发现问题确实不难:smile:]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些小细节]]></title>
    <url>%2F%2F2019%2F07%2F21%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[导入jar包时看清哪些类在哪些包下，可以参考一下API（入伏能找到的话），确认这个类不在所有可运行的包下之后再去网上找jar包]]></content>
      <categories>
        <category>踩坑实录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown编辑器Typora]]></title>
    <url>%2F%2F2019%2F07%2F21%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8Typora%2F</url>
    <content type="text"><![CDATA[Typora快捷键目录 windows快捷键： 给代码块设置快捷键: Mac中的快捷键： 图片： 表情 数学公式 HTML 行内嵌数学符号 下标 高亮 参考： windows快捷键：# 无序列表：输入-之后输入空格 有序列表：输入数字+“.”之后输入空格 任务列表：-[空格]空格 文字 标题：ctrl+数字 表格：ctrl+t 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 代码块：ctrl+alt+f 加粗：ctrl+b 倾斜：ctrl+i 下划线：ctrl+u 删除线：alt+shift+5 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 插入链接：ctrl + k 搜索最近打开的文件：Ctrl+k 给代码块设置快捷键:#偏好设置-&gt;打开高级设置-&gt;conf.user.json文件 12345678"keyBinding": &#123; // for example: // "Always on Top": "Ctrl+Shift+P" "Always on Top": "Ctrl+Shift+P", "Code Fences": "Ctrl+Shift+F", "Ordered List":"Ctrl+Alt+o", "Unordered List": "Ctrl+Alt+u" &#125;, Code Fences 代码块 Ordered List 数字有序列表 Unordered List 无序列表 转自：hongda]]></content>
      <categories>
        <category>其他软件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[html的常用标签]]></title>
    <url>%2F%2F2019%2F07%2F21%2Fhtml%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[在html中插入音频]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xml(一)]]></title>
    <url>%2F%2F2019%2F07%2F21%2Fxml-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[xml概述 xml标准文档的极佳版本 xml是一种能表示层次结构的标记语言，比属性文件的平面表结构更灵活，它与html较为类似 区别如下： 1.xml是大小写敏感的，如， 1&lt;H1&gt; 和 1&lt;h1&gt; 是不同的xml标签 2.在xml中，只有一个标签而无相应的尾标签的元素必须以/结尾，比如 1&lt;img src="" /&gt; ，这样，解析器就不必查找 1&lt;/img&gt; 标签了。 3.在xml中，属性值必须用引号括起来，在html中，引号是可有可无的，如 1&lt;applet code="" width=300 height=400&gt; 对html来说是合法的，但对xml来说不合法。 4.在html中属性可以没有值，如， 1&lt;input type="radio" name="hhh" value="hhh" checked&gt; ，在xml中所有属性都必须有值。 xml文档的结构 xml应当以一个文档头开始，如： 1&lt;?xml version="1.0" encoding="UTF-8"?&gt; 文档头之后通常是文档类型定义，如: 1&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DAD Web Application 2.2//EN" "http://java.sun.com/j2ee/dtds/web-app_2_2.dtd"&gt; 最后xml文档的正文包含根元素，根元素包含一些其他的元素。如： 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration...&gt;&lt;configuration&gt; &lt;title&gt; &lt;font&gt; &lt;name&gt;Helvetica&lt;/name&gt; &lt;size&gt;36&lt;/size&gt; &lt;/font&gt; &lt;/title&gt;&lt;/configuration&gt; 元素可以有子元素、文本或者两者皆有（在设计xml文档时，最好使元素要么包含子元素，要么包含文本，应该避免以下情况：在xml规范中，这叫做混合式内容，避免了混合式内容可以简化简化解析过程。） 1234&lt;font&gt; Helvetica &lt;size&gt;35&lt;/size&gt;&lt;/font&gt; 属性只应在修改值的解释时使用，而不是指定值时使用。 元素和文档是xml文档的“主要支撑要素”，以下是一些标记说明 字符引用的形式是&amp;#十进制值，或者&amp;#x十六进制值，如字符e可以用下面两种形式表示： &amp;#233； &amp;#xD9； 实体引用的形式是&name;。下面这些实体引用：&amp;lt；&amp;gt；&amp;amp；&amp;quot；&amp;apos；分别表示&lt;，&gt;，&amp;，’，…等字符，可以在DTD中定义其他的实体引用。 CDATA部分用&lt;![CDATA[和]]&gt;来限定其界限。他们是字符数据的一种特殊形式。你可以使用它们来包含那些含有&lt;，&gt;，&amp;之类字符的字符串，而不必将它们解释为标记，例如： 1&lt;![CDATA[&lt; &amp; &gt; are myfavourate delimiters]]&gt; CDATA部分不能包含字符串]]&gt;。使用这一特性时要特别注意。它常用来当做将传统数据偷偷纳入XML文档的一个后门。 处理指令（processing instruction）是那些专门在处理xml文档的应用程序中使用的指令，它们将用&lt;?和?&gt;来限定其界限，例如： 1&lt;?xml-stylesheet href="mystyle.css" type="text/css"?&gt; 每个xml都以下面这个处理指令开头： &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 注释用&lt;!– 和–!&gt;来限定其界限：&lt;!– 这是一个注释 –!&gt; 解析xml文档一、基于文档对象模型（DOM）的树形解析器 DOM解析器对于实现我们的大多数目的来说都很容易，不过用它生成树结构会消耗大量内存。JDK中自己包含的有DOM解析器，我们可以直接拿来用 下面的代码使用了DOM解析器解析了相关的xml文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package domtree;import java.io.File;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.w3c.dom.Text;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();//DocumentBuilderFactory实例化 File file=new File("src/web.xml");//classpath下的一个xml文件 try &#123; DocumentBuilder builder=factory.newDocumentBuilder(); Document doc=builder.parse(file);//选择输入源，可以是文件或者是URL: //Document doc=builder.parse(url);或者是一个输入流： //Document doc=builder.parse(inputStream); //如果使用输入流作为输入源，当这个源的初始化对象是那些相对于文档位置定位的文件时 //解析器将无法定位，但是可以通过安装一个“实体分解器（entity resolver）” //来解决这个问题 Element root =doc.getDocumentElement();//获得根节点 treeParser("",root);//递归的访问元素节点 //System.out.println("hhhh\thhhh");测试tab &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void treeParser(String tab,Element element)&#123; System.out.println(tab+element.getTagName());//打印元素节点名称 NodeList childrens=element.getChildNodes();//获得元素节点的所有子节点 if(childrens.getLength()&gt;1)&#123;//若元素节点的子节点还有元素节点 for(int i=0;i&lt;childrens.getLength();i++)&#123;//遍历element的所有子节点 Node child=childrens.item(i); if(child instanceof Element)&#123;//若其是元素节点，则递归的访问其子节点 treeParser(tab+"\t",(Element)child); &#125; &#125; &#125;else&#123;//element元素节点下只剩数据，则输出其数据 System.out.print(tab+"\t"); System.out.println( ((Text)element.getFirstChild()) .getData().trim());// &#125; System.out.println(tab+element.getTagName());//再次输出元素节点名称 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;!-- 配置 org.springframework.web.filter.HiddenHttpMethodFilter: 可以把 POST 请求转为 DELETE 或 POST 请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置 DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置 DispatcherServlet 的一个初始化参数: 配置 SpringMVC 配置文件的位置和名称 --&gt; &lt;!-- 实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认的. 默认的配置文件为: /WEB-INF/&lt;servlet-name&gt;-servlet.xml --&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 二、基于xml简单API的（SAX）的流机制解析器（事件回调方式） SAX解析器在解析XML输入的控件时就报告事件，但不会以任何方式存储文档。 在使用SAX解析器时，需要一个处理器来定义不同的解析器事件的事件动作。他们都实现了ContentHandler接口。ContentHandler接口定义了几个回调方法。最常用的如下 startElement和endElement在每当遇到起始或终止标签是调用。 characters每当遇到字符数据时调用。 startDocument和endDocument分别在文档开始和结束时各调用一次。 例如解析以下片段时： 1234&lt;font&gt; &lt;name&gt;Helvetica&lt;/name&gt; &lt;size units="pt"&gt;36&lt;/size&gt;&lt;/font&gt; 解析器会有以下调用： startElement，元素名：font startElement，元素名：name characters，内容：Helvetica endElement，元素名：name startElement，元素名：size，属性：units=“pt” characters，内容：36 endElement，元素名：size endElement，元素名：font 示例程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package saxtest;import java.io.InputStream;import java.net.URL;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import org.xml.sax.Attributes;import org.xml.sax.helpers.DefaultHandler;public class SAXTest&#123; public static void main(String[] args) throws Exception &#123; String url; if (args.length == 0) &#123; url = "http://www.w3c.org"; System.out.println("Using " + url); &#125; else url = args[0]; DefaultHandler handler = new DefaultHandler()//用匿名内部类实例化处理器 &#123; public void startElement(String namespaceURI, String lname, String qname, Attributes attrs) &#123; //namespaceURL:命名空间 //lname：本地名 //qname：以alias：localname形式表示的限定名 //attrs：元素属性集合 if (lname.equals("a") &amp;&amp; attrs != null) &#123; for (int i = 0; i &lt; attrs.getLength(); i++)//对属性集合遍历 &#123; String aname = attrs.getLocalName(i);//获得属性的本地名 if (aname.equals("href")) System.out.println(attrs.getValue(i)); //打印输出属性值 &#125; &#125; &#125; &#125;; SAXParserFactory factory = SAXParserFactory.newInstance(); factory.setNamespaceAware(true);//设置命名空间可用 SAXParser saxParser = factory.newSAXParser();//获取SAX解析器 InputStream in = new URL(url).openStream();//获得输入流 saxParser.parse(in, handler); //根据传入的输入流（可以是文件，URL等）和处理器来处理xml文件 //处理器必须是DefaultHandler的子类，DefaultHandler类为以下接口定义了空的方法： //ContentHandler，DTDHandler，EntityResolver，ErrorHandler &#125;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[绘制图表软件visio]]></title>
    <url>%2F%2F2019%2F07%2F20%2F%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E8%BD%AF%E4%BB%B6visio%2F</url>
    <content type="text"><![CDATA[visio常用快捷键 复制 按ctrl+拖动 水平/垂直复制 按ctrl+shift+ 拖动（水平/垂直） 水平/垂直移动 按shift+拖动 放大 ctrl+滚轮 键拖动幕布 ctrl+alt+鼠标右 水平滚动画布 shift+滚轮 选择工具 ctrl+1 文字工具 ctrl+2 连接线 ctrl+3 形状工具 ctrl+8 文本（加粗/斜体/删除线） ctrl+b/i/u 字体变大/小 ctrl+shift+,/. 矩形→正方形/椭圆→圆形/直线→水平/垂直或45°线 shift 组合/取消组合 ctrl+g/ctrl+shift+u 字体下标/上标 ctrl+＝/ctrl+shift+＝ 保存 F12Visio 使用小技巧 选中图形，左下角可以调出大小和位置。 取消箭头自动连接 进去visio视图-&gt;视觉帮助 右下角点三角形把当前活动的中的对齐粘附选项全部取消掉。 鼠标按住尺规的边缘往外拉，会拉出一条绘图辅助线，按del键就会消失，而且选中这条线，按ctrl+L会旋转90°。选粘附到参考线。当拖动图形靠近辅助线时，将锁定图形位置。 选择对齐方式时，是以第一个被选中的图形为基准。左对齐：以第一个图形的左边框为基准线对齐；其他类似。 连接线上添加文字——在连接线上双击鼠标左键，即可添加文字。添加完毕后，按住文字中间的黄色菱形，课任意拖放文字的位置。 搜索形状的搜索栏很好用，你可以在里面找到同一类型不同样式的图形。比如搜索‘连接器’，就会出现上百个不同样式的连接器。 转自：https://blog.csdn.net/sinat_20311715/article/details/80858859 去掉绘图背景右击图形， 选择格式，再点里面的填充 选择”图案颜色”的对应的下拉菜单。选择“无”，点击确定，再看，图形形状就变成透明的了， 绘图图片输出步骤如下： https://jingyan.baidu.com/article/48b558e336a8a17f38c09a9e.html 线段点对齐如下所示，鼠标悬浮不动，按上键或下键，可以微调线段的位置]]></content>
      <categories>
        <category>其他软件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java流家族]]></title>
    <url>%2F%2F2019%2F07%2F20%2Fjava%E6%B5%81%E5%AE%B6%E6%97%8F%2F</url>
    <content type="text"><![CDATA[java流家族类及接口继承结构如下： 字节流： 字符流：]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>io</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DataOutputStream二进制输入输出时存在的问题]]></title>
    <url>%2F%2F2019%2F07%2F20%2FDataOutputStream%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>java学习笔记</category>
        <category>io</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次踩坑记录：hexo配置文件package]]></title>
    <url>%2F%2F2019%2F07%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%9Ahexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6package%2F</url>
    <content type="text"><![CDATA[哎呀花了我大半天时间终于把这个bug给解决了，都是当时我乱改配置文件惹的祸，发誓再也不乱改配置文件了。。。 ​ 之前发现的问题是我的hexo不能正常显示我的Markdown文本内嵌的html标签，到网上好一阵百度，终于证明不是hexo的锅，没错，这锅应该我来背，，这配置文件改的太久了，都过去了好几个月了，早忘了当时自己改了啥了， ​ 记一下解决办法吧，虽然还没意识到问题的本质，解决如下： ​ 重新初始化一个hexo项目文件夹，进行隔离测试（这是个好办法，出现不明原因bug时要记得经常使用），不断地将之前的配置拿到新文件夹中测试，先是对主题测试，证明不是主题配置的问题，之后再对_config.xml文件进行测试，结果没问题，而后在对hexo主目录下的package.json文件内节点进行逐项测试（而我比较懒，就没有逐项），证明是此文件的配置项的问题后，之后将老站点的资源文件及相关有效配置迁移到新站点]]></content>
      <categories>
        <category>前端</category>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>踩坑实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立志做一个勤奋的笔耕者]]></title>
    <url>%2F%2F2019%2F07%2F19%2F%E7%AB%8B%E5%BF%97%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8B%A4%E5%A5%8B%E7%9A%84%E7%AC%94%E8%80%95%E8%80%85%2F</url>
    <content type="text"><![CDATA[​ 花了五六个小时的时间，利用hexo框架总算是把我的个人博客给搭建起来了，实属不易呀，并且完成了在GitHub上的静态发布。 ​ 搭建个人博客对程序员来说是挺重要的一件事，可以在个人博客上写一些个人的学习笔记，知识总结，加深自己对相关知识的理解，还有一些踩坑记录，避免自己再次踩坑:grin:，以后还可以在上面放一些生活随笔。下搭建个人博客决心的过程有点艰难，本来很早的时候就有过搭建个人博客的想法，可是那个时候感觉，写个人博客的都是技术大拿，自己作为一个程序猿小透明，不会也没有必要去写个人博客，感觉写了也没人看，这么长时间经历了蛮多事，同学们大都考研了，自己找实习的过程中又屡遭碰壁，感觉自己的基础知识极度不扎实，有些知识点说明白也明白点，可但往深处一问，就有啥都不会了，更让自己无法接受的是那个说自己基础不扎实的面试官还是自己的同龄。幸而有个学长给自己指明了现阶段的方向，终于决定暑假恶补自己的java的基础知识，外加数据库（mysql）和开发框架（spring全家桶），无奈学习效率不尽如人意，感觉看过教学视频后再在总结为一篇博客效果会好点。 博客更新计划如下： 1.框架部分准备一日多更 2.java部分一日一更 3.其他博文周更 具体步骤参见个人博客的搭建。 ​]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为你的hexo添加表情]]></title>
    <url>%2F%2F2019%2F07%2F19%2F%E4%B8%BA%E4%BD%A0%E7%9A%84hexo%E6%B7%BB%E5%8A%A0%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客的搭建]]></title>
    <url>%2F%2F2019%2F07%2F19%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[我采用的是hexo博客框架 搭建过程需要一下步骤： 1.安装git 2.安装Nodejs 3.安装hexo（包括以上两项都可以去官网下载，直接安装，没毛病） 4.需要在github上注册一个账号，已有可自动忽略 生成hexo目录及更改hexo的配置文件以上算是搭建完成了，之后需要新建一个文件夹你的git usename（或者其他），cd进入此文件夹，执行： hexo init 会默认在当前文件夹下生成hexo的目录，目录及命令介绍详见hexo文档，详细阅读之后能了解hexo的目录架构，及工作方式，同时更改_config.yml的配置 修改主题在_config.yml配置文件中有个theme字段中可更改主题，next挺好用的，详细配置参见https://www.jianshu.com/p/b75146d016e6及next文档http://theme-next.iissnan.com/getting-started.html]]></content>
      <categories>
        <category>前端</category>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat导入源码]]></title>
    <url>%2F%2F2019%2F07%2F19%2FTomcat%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java与编码]]></title>
    <url>%2F%2F2019%2F07%2F19%2Fjava%E4%B8%8E%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[utf-16编码​ 先解释一下utf-16编码： ​ 原文链接：https://blog.csdn.net/wusj3/article/details/88641084 java与utf-16​ 从jdk 5.0开始。代码点是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，代码点采用十六进制书写，并加上前缀U+，例如U+0041就是字母A的代码点。Unicode的代码点可以分为十七个代码级别。第一个代码级别被称为基本的多语言级别，代码点从U+0000到U+FFFF，其中包含了经典的Unicode代码；其余的十六个附加级别代码点从U+10000到U+10FFFF，其中包含了一些辅助字符，辅助字符一般采用一对连续的的代码单元表示 在java中，char类型用UTF-16编码描述一个代码单元]]></content>
      <categories>
        <category>我眼中的java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo中next的其他配置]]></title>
    <url>%2F%2F2019%2F07%2F19%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%98%BE%E7%A4%BA%E6%91%98%E8%A6%81%E5%92%8C%E9%98%85%E8%AF%BB%E5%8E%9F%E6%96%87%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[1.Hexo博客NexT主题下显示摘要和阅读原文按钮转自https://blog.csdn.net/mqdxiaoxiao/article/details/93263923 2. 我可以设置这一句的颜色哈哈]]></content>
      <categories>
        <category>前端</category>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%2F2019%2F07%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>

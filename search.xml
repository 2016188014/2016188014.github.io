<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot内置的tomcat]]></title>
    <url>%2F2019%2F10%2F28%2Fspringboot%E5%86%85%E7%BD%AE%E7%9A%84tomcat%2F</url>
    <content type="text"><![CDATA[在看尚硅谷的教程时，跟着写了一遍springboot的拦截器，主要代码如下 12345678910111213141516171819public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 /* HttpSession session=(HttpSession)request.getSession(); session.setAttribute("msg","没有权限请先登陆");*/ //request.getRequestDispatcher("/login.html").forward(request,response); response.sendRedirect("/crud/index.html"); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; 结果发现它会拦截静态资源，这和老师讲的不一样呀，于是就网上查，发现是spingboot版本的问题，我用的是2.2.0，静态资源也全部拦截了，而且还抛了个异常（瞧我这暴脾气）： 12345java.lang.AbstractMethodError: org.apache.tomcat.websocket.server.WsSessionListener.sessionCreated(Ljavax/servlet/http/HttpSessionEvent;)V at org.apache.catalina.session.StandardSession.tellNew(StandardSession.java:388) [tomcat-embed-core-9.0.27.jar:9.0.27] at org.apache.catalina.session.StandardSession.setId(StandardSession.java:360) [tomcat-embed-core-9.0.27.jar:9.0.27] at org.apache.catalina.session.StandardSession.setId(StandardSession.java:341) [tomcat-embed-core-9.0.27.jar:9.0.27] at org.apache.catalina.session.ManagerBase.createSession(ManagerBase.java:686) springboot2.2.0默认Tomcat是9.0.27版本的，使用servlet4.0，但是SpringBoot 2.x还包含着 servlet3.1，版本不兼容，网上说的解决办法是在pom里更换Tomcat为低版本，可是之后发现springboot在调用Tomcat9.0.27中新添加的部分接口，强行更换会报异常： 123An attempt was made to call a method that does not exist. The attempt was made from the following location: org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:175)The following method did not exist: org.apache.tomcat.util.modeler.Registry.disableRegistry()V 未找到解决办法 待续。。。 var gitment = new Gitment({ //id: '', // 可选。默认为 location.href owner: 'bigengzhe', repo: 'Hexo_Next_comments', oauth: { client_id: 'Iv1.386783709022d748', client_secret: 'c279ecc939829ce19ee8bd888f122b54b4a63231', }, }) gitment.render('container')]]></content>
      <tags>
        <tag>踩坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataRedis常见操作]]></title>
    <url>%2F2019%2F10%2F21%2FSpringDataRedis%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[string类型 向redis中存值：redisTemplate.boundValueOps(“name”).set(“bruce”); 从redis中取值：redisTemplate.boundValueOps(“name”).get() 得到字符串的长度，工作的不太正常：redisTemplate.boundValueOps(“name”).size(); set类型 向redis中存值：redisTemplate.boundSetOps(“nameset”).add(“曹操”); 从redis中获取set所有元素：Set set= redisTemplate.boundSetOps(“nameset”).members(); 从set中删除元素：redisTemplate.boundSetOps(“nameset”).remove(“诸葛亮”); 删除set集合：redisTemplate.delete(“nameset”); List类型 向List尾部添加数据：redisTemplate.boundListOps(“nameList1”).rightPush(“刘备”); 获得指定索引范围List数据：redisTemplate.boundListOps(“nameList1”).range(1,10); 删除List：redisTemplate.delete(“nameList1”); 在指定方向删除指定数目的List，类似于jedis.lrem(“list”, 2, “value”);: redisTemplate.boundListOps(“nameList1”).remove(1,”曹操”); Hash类型 向Hash中添加元素：redisTemplate.boundHashOps(“nameHash”).put(“a”,”aa”); 获取Hash中所有key：redisTemplate.boundHashOps(“nameHash”).keys(); 获取Hash中所有value：redisTemplate.boundHashOps(“nameHash”).values(); 获取指定value的值：redisTemplate.boundHashOps(“nameHash”).get(“a”); 删除指定key的键值对：redisTemplate.boundHashOps(“nameHash”).delete(“a”); ZSet类型 向ZSet中添加值：redisTemplate.boundZSetOps(“zSetValue”).add(“A”,1); 获取ZSet中所有值：redisTemplate.boundZSetOps(“zSetValue”).range(0,-1); ZSet中多值添加： 1234ZSetOperations.TypedTuple&lt;Object&gt; z1=new DefaultTypedTuple&lt;Object&gt;("zset-1",9.6); Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; values=new HashSet&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt;(); values.add(z1); redisTemplate.boundZSetOps("zSetValue").add(values); ZSet中删除指定的值：redisTemplate.boundZSetOps(“zsetValue”).remove(“zset-1”); 为ZSet中某一value增加指定的比重：redisTemplate.boundZSetOps(“zSetValue”).incrementScore(“zset-1”,1.1); 获得ZSet中某一value在有序排列中的顺序：redisTemplate.boundZSetOps(“zSetValue”).rank(“zset-1”); 用迭代方式遍历ZSet： 123456Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples= redisTemplate.boundZSetOps("zSetValue").rangeWithScores(0,-1); Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator=tuples.iterator(); while(iterator.hasNext())&#123; ZSetOperations.TypedTuple&lt;Object&gt; typedTuple=iterator.next(); System.out.println("value: "+typedTuple.getValue()+"score:"+typedTuple.getScore()); &#125; 得到ZSet集合的大小：redisTemplate.boundZSetOps(“zSetValue”).zCard(); 删除指定索引的元素：redisTemplate.boundZSetOps(“zSetValue”).removeRange(1,2);]]></content>
  </entry>
  <entry>
    <title><![CDATA[static块的执行顺序问题]]></title>
    <url>%2F2019%2F10%2F08%2Fstatic%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[代码如下 123456789101112131415161718192021222324252627public class Test &#123;public static void main(String[] args) &#123; B b=new B(); &#125; static&#123; System.out.println("Test static块执行"); &#125; public Test()&#123; System.out.println("Test类初始化。。。。。"); &#125; static class A&#123; static&#123; System.out.println("A的static块执行"); &#125; public A()&#123; System.out.println("A类初始化。。。。。"); &#125; &#125; static class B extends A&#123; static &#123; System.out.println("B的static初始化"); &#125; public B()&#123; System.out.println("B类初始化。。。。。"); &#125; &#125;&#125; 输出如下]]></content>
  </entry>
  <entry>
    <title><![CDATA[java四大引用]]></title>
    <url>%2F2019%2F10%2F05%2Fjava%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[软引用 123456789101112131415161718192021222324package nowcoder;import java.lang.ref.SoftReference;public class Test &#123; private static class Bigger&#123; public int[] values; public String name; public Bigger(String name)&#123; this.name=name; values=new int[1024]; &#125; &#125; public static void main(String[] args) &#123; int count =1000000; SoftReference[] values=new SoftReference[count]; for(int i=0;i&lt;count;i++)&#123; values[i]=new SoftReference&lt;Bigger&gt;(new Bigger("bigger-"+i)); &#125; for(int i=0;i&lt;10;i++)&#123; System.out.println(((Bigger)(values[i].get())).name); &#125; &#125;&#125; 输出如下： 总结：软引用用来描述一些还有用，但并非必须的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中，并进行二次回收，如果这次回收还是没有足够的内存，才会抛出内存不足异常]]></content>
  </entry>
  <entry>
    <title><![CDATA[collection.add（ArrayList）源码分析]]></title>
    <url>%2F2019%2F10%2F01%2Fcollection-add%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[相关源码截取如下： 12345678910111213141516171819202122232425262728293031323334353637383940public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! //size初始为0 elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123;//为1 ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity);//设默认大小为10 &#125; return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 总结：ArrayList中存放的elementData仅是个对象数组，别无其他，]]></content>
      <categories>
        <category>我眼中的java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爬虫初体验（爬了牛客）]]></title>
    <url>%2F2019%2F09%2F29%2F%E7%88%AC%E8%99%AB%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%88%E7%88%AC%E4%BA%86%E7%89%9B%E5%AE%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[起初不知为何有个路径为何抛FileNotFound异常，后来此异常有无缘无故消失了，很奇怪，代码写的很渣，不过总归是爬到了，代码如下 主程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package socket;import java.io.*;import java.net.*;import java.util.*;public class SocketTest&#123; public static void main(String[] args) throws IOException &#123;//13 try &#123; URL url=new URL("https://www.nowcoder.com/school/schedule"); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoInput(true); connection.setRequestProperty("Host", "www.nowcoder.com"); connection.setRequestProperty("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36"); connection.setRequestProperty("path", "/recommend"); connection.setRequestProperty("authority", "www.nowcoder.com"); connection.setRequestProperty("scheme", "https"); connection.setRequestProperty("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3"); //connection.setRequestProperty("accept-encoding", "gzip, deflate, br"); //connection.setRequestProperty("referer", "https://www.nowcoder.com/ta/sql"); connection.setRequestProperty("method", "GET"); //connection.setRequestProperty("accept-language", "zh-CN,zh;q=0.9,en;q=0.8"); connection.connect(); Scanner in = new Scanner(connection.getInputStream(), "UTF-8"); String str1="&lt;li class=\" js-company-item\" data-id=\"665\"&gt;"; String regex1="&lt;li class=\" js-company-item\".+";//匹配最开始的li标签 String str2="&lt;h2&gt;字节跳动&lt;/h2&gt;"; String regex2="(&lt;h2&gt;)|(&lt;/h2&gt;)";//匹配之后出现的公司名 String str3="&lt;div class=\"act-company-info resume\"&gt;网申&lt;span class=\"act-company-time\"&gt;8月16日起&lt;/span&gt;&lt;/div&gt;"; String regex3="(&lt;div class=\"act-company-info resume\"&gt;网申&lt;span class=\"act-company-time\"&gt;)|(&lt;/span&gt;&lt;/div&gt;)"; //匹配最后出现的原始日期字符串 List&lt;Recruitment&gt; list=new ArrayList&lt;&gt;(); List&lt;Recruitment&gt; other=new ArrayList&lt;&gt;(); Collection&lt;Integer&gt; lengths=new TreeSet&lt;&gt;(); while (in.hasNextLine()) &#123; String line = in.nextLine(); if(line.matches(regex1))&#123;//判断是否出现指定的li，如出现则进入内层循环 while(in.hasNextLine())&#123; String hline=in.nextLine(); String cname=null; String origindate=null; //System.out.println(hline); if(hline.matches("&lt;h2&gt;.+&lt;/h2&gt;"))&#123; cname=hline.replaceAll(regex2, "").trim();//提取出现的公司名 while(in.hasNextLine())&#123; String dline=in.nextLine(); if(dline.matches("&lt;div class=\"act-company-info resume\"&gt;网申&lt;span class=\"act-company-time\"&gt;.*&lt;/span&gt;&lt;/div&gt;"))&#123; origindate=dline.replaceAll(regex3, "").trim(); if(origindate!=null &amp;&amp;!"".equals(origindate))&#123;//防止匹配上空值 if(origindate.contains("-"))&#123; String [] strs= origindate.split("-+")[1].split("(\\D)+");//得到结束日期字符串数组 list.add(new Recruitment(cname,formString(strs,origindate),origindate)); &#125;else if(origindate.endsWith("截止"))&#123; String [] strs= origindate.split("(\\D)+"); list.add(new Recruitment(cname,formString(strs,origindate),origindate)); &#125;else&#123; other.add(new Recruitment(cname,origindate)); &#125; lengths.add(origindate.length()); /*if(origindate.length()==2)&#123; System.out.printf("%-20s%10s\n",cname,origindate); //System.out.println(origindate.split("(\\D)+").length); &#125;*/ &#125; break; &#125; &#125; break; &#125; &#125; &#125; //System.out.println(line); &#125; Collections.sort(list); for (Recruitment recruitment : list) &#123; System.out.println(recruitment); &#125; for (Recruitment recruitment : other) &#123; System.out.println(recruitment); &#125; System.out.println(list.size()); System.out.println(other.size()); System.out.println(lengths); &#125;catch(Exception e)&#123; System.out.println(e); &#125; &#125; public static Date formString(String[] strs,String ostr)&#123; Date date=null; if(strs.length==1)&#123; if(ostr.endsWith("下旬")|| ostr.endsWith("底"))&#123; date=new GregorianCalendar(119+1900,Integer.parseInt(strs[0])-1,29).getTime(); &#125;else if(ostr.endsWith("中旬"))&#123; date=new GregorianCalendar(119+1900,Integer.parseInt(strs[0])-1,15).getTime(); &#125;else if(ostr.endsWith("上旬")||ostr.endsWith("初"))&#123; date=new GregorianCalendar(119+1900,Integer.parseInt(strs[0])-1,5).getTime(); &#125;else&#123; date=new GregorianCalendar(119+1900,Integer.parseInt(strs[0])-1,1).getTime(); &#125; &#125;else if(strs.length==2||strs.length==4)&#123; date=new GregorianCalendar(119+1900,Integer.parseInt(strs[0])-1,Integer.parseInt(strs[1])).getTime(); &#125;else if(Integer.parseInt(strs[0])&gt;12&amp;&amp;strs.length==3)&#123; //System.out.println(Arrays.toString(strs)); date=new GregorianCalendar(119+1900,Integer.parseInt(strs[1])-1,Integer.parseInt(strs[2])).getTime(); &#125;else&#123; date=new Date(); &#125; return date; &#125;&#125; 相关类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package socket;import java.text.SimpleDateFormat;import java.util.Date;public class Recruitment implements Comparable&lt;Recruitment&gt;&#123; private String name; private Date edate;//结束日期 private String origindate; public String getName() &#123; return name; &#125; public Date getEdate() &#123; return edate; &#125; public String getOrigindate() &#123; return origindate; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setEdate(Date edate) &#123; this.edate = edate; &#125; public void setOrigindate(String origindate) &#123; this.origindate = origindate; &#125; public Recruitment(String name, Date edate, String origindate) &#123; super(); this.name = name; this.edate = edate; this.origindate = origindate; &#125; public Recruitment(String name, String origindate) &#123; super(); this.name = name; this.origindate = origindate; &#125; @Override public int compareTo(Recruitment o) &#123; // TODO Auto-generated method stub return this.edate.compareTo(o.getEdate()); &#125; @Override public String toString() &#123; SimpleDateFormat pat=new SimpleDateFormat("yyyy 年 MM 月 dd 日"); if(this.edate!=null) return "Recruitment [name=" + name + ", edate=" + pat.format(edate) + ", origindate=" + origindate ; else return "Recruitment [name=" + name +", origindate=" + origindate ; &#125; &#125; 运行结果： 总结：网络编程的知识之前学到过一些，不过很浅显，这次自己动手加深了印象（以后查牛客也更方便了些23333），问题主要在对java网络类的底层实现不太了解，自己网络的基础比较薄弱，还有正则的验证也是个问题，想要涵盖所有的情况，提取相关信息，比较难（套了三层循环，不知是否有相关的简化办法？）]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些面试题]]></title>
    <url>%2F2019%2F09%2F28%2F%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[以下代码可以可以编译通过吗，可以的话输出为？ 1234public static void main(String[] args) &#123; int i; System.out.println(i);&#125; 答：不能编译通过，提示变量未初始化 对volatile变量的操作会造成阻塞吗？答：不会 不依赖其他锁机制，多线程环境下的计数器可用volatile实现吗？答：多线程下计数器必须使用锁保护。 synchronized关键字不可以加给类，且属于可重入锁]]></content>
  </entry>
  <entry>
    <title><![CDATA[collection中常用方法二三事]]></title>
    <url>%2F2019%2F09%2F25%2Fcollection%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[containsAll：此方法工作方式并不如人意，它是对比较集合逐个调用contains方法，源码参考如下 1234567public boolean containsAll(Collection&lt;?&gt; c) &#123; Iterator&lt;?&gt; e = c.iterator(); while (e.hasNext()) if (!contains(e.next())) return false; return true; &#125; contains：源码参考 1234567891011Iterator&lt;E&gt; it = iterator();if (o==null) &#123; while (it.hasNext()) if (it.next()==null) return true;&#125; else &#123; while (it.hasNext()) if (o.equals(it.next())) return true;&#125;return false;]]></content>
      <categories>
        <category>我眼中的java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库备份踩坑]]></title>
    <url>%2F2019%2F09%2F19%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[mysql数据库导出时记得不要勾选上二进制大文件，血淋淋的教训，不是乱码的问题，只是导出有限制]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>踩坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT算法导论公开课笔记]]></title>
    <url>%2F2019%2F09%2F08%2FMIT%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[时间复杂度的计算：​ 忽略最高项的所有低阶项和它的系数，如： ​ 3n^3+90n^2-5n+78-&gt;θ(n^3) 插入排序的时间复杂度为θ(n^2)T(n)=∑(j=2-&gt;n)θ(j)=θ(n^2)]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jsp二三事]]></title>
    <url>%2F2019%2F09%2F06%2Fjsp%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[在jsp中，html标签是相对于浏览器路径，jsp标签是相对于服务器路径]]></content>
      <categories>
        <category>jee</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组copy]]></title>
    <url>%2F2019%2F09%2F03%2F%E6%95%B0%E7%BB%84copy%2F</url>
    <content type="text"><![CDATA[目前在Java中数据拷贝提供了如下方式： clone System.arraycopy Arrays.copyOf Arrays.copyOfRange 以上属于浅copy，只能copy基本类型和String，对于引用类型则会失效 关于foreach对栈的访问，会对栈自底至顶的访问，比如入栈1,2,3；出栈顺序还是1,2,3 123for(int value : stack1)&#123; stack2.push(value);&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>对象与类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[项目bug]]></title>
    <url>%2F2019%2F09%2F01%2F%E9%A1%B9%E7%9B%AEbug%2F</url>
    <content type="text"><![CDATA[org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sqlSessionFactory’ defined in file [C:\Program Files\Apache Software Foundation\Tomcat 8.0\webapps\Atcrowdfunding-main\WEB-INF\classes\spring\spring-context.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse config resource: class path resource [mybatis/mybatis-config.xml]; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error registering typeAlias for ‘user’. Cause: java.lang.ClassNotFoundException: Cannot find class: User user类找不到，可以将相关配置先注释掉]]></content>
  </entry>
  <entry>
    <title><![CDATA[mvn中jar包问题]]></title>
    <url>%2F2019%2F08%2F30%2Fmvn%E4%B8%ADjar%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在mvn中导入jar包 12&lt;groupId&gt;org.activiti&lt;/groupId&gt;&lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; 遇到以下错误提示 1Missing artifact org.vaadin.addons:dcharts-widget:jar:0.10.0 刚开始以为是jar包缺失，而后导入jar包后还是报错，且本项目中并未配置此jar包 google得知，可能是由于jar包冲突，可用以下方法解决，剔除掉重复的jar包 123456&lt;exclusions&gt;&lt;exclusion&gt;&lt;groupId&gt;org.vaadin.addons&lt;/groupId&gt;&lt;artifactId&gt;dcharts-widget&lt;/artifactId&gt;&lt;/exclusion&gt;&lt;/exclusions&gt;]]></content>
      <categories>
        <category>mvn</category>
      </categories>
      <tags>
        <tag>踩坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码安装apt-get]]></title>
    <url>%2F2019%2F08%2F27%2F%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85apt-get%2F</url>
    <content type="text"><![CDATA[下载好apt-get的源码包后用bunzip2或者带-d选项的bzip2命令解压压缩包 12bunzip2 apt-0.5.15lorg3.tar.bz2tar -xvf apt-0.5.15lorg3.tar 遇到问题 1configure: error: Can&apos;t find libbz2 library bzip2-libs is the equivalent package to the Debian/Ubuntu libbz2 12345cat &gt;&gt;confdefs.h &lt;&lt;_ACEOF#define RPM_VERSION_RAW &quot;$RPM_VERSION_RAW&quot;_ACEOFecho &quot;$as_me:$LINENO: checking for BZ2_bzopen in -lbz2&quot; &gt;&amp;5 以上不懂，弃]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[众筹网]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%BC%97%E7%AD%B9%E7%BD%91%2F</url>
    <content type="text"><![CDATA[管理端 尚筹网页面原型/main.html1. 权限管理 1. 用户维护（增删改查）尚筹网页面原型/user.html 2. 角色维护（同上）尚筹网页面原型/role.html 3. 许可维护 尚筹网页面原型/permission.html 2. 业务审核（功能同上） 3. 业务管理（功能同上） 用户端 尚筹网页面原型/index.html1. 众筹商品提交流程（信息入库）尚筹网页面原型/start-step-1.html 2. 个人中心 1. 资产总览（有图表展示，用了echart插件，需要弄明白）尚筹网页面原型/member.html 2. 我的众筹（）尚筹网页面原型/member.html 3. 实名认证（选做）]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux虚拟机网络配置]]></title>
    <url>%2F2019%2F08%2F26%2Flinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[VMware Workstation Pro中有三种网络设置方式：桥接模式、NAT模式、仅主机模式 桥接模式：将你的虚拟机以一个真实机方式连接到互联网上、会占用当前网络的一个ip（注意此ip不能被其他计算机占用），设置虚拟机的ip和子网掩码与网关确保他们位于同一网段，可能还需要设置DNS与默认路由，还要注意桥接方式。 优点：设置方便，不仅可以与本主机通信，虚拟机还可连接到互联网 仅主机模式：通常与VMnet1相关联只与本主机通信无法连接到互联网。本方式需要更改虚拟机ip及子网掩码，同样需要确保与真实机位于同一网段。不能连接到互联网 NAT模式：一般与VMnet8相关联，此方式比以上稍微复杂些。相比于桥接模式，此方式需要虚拟机和VMnet8位于同一网段，其他桥接所要做的设置其同样也不能少，除此外还要注意以下 为使以上配置永久生效，可将配置写入配置文件，以下网址可备参考 https://www.cnblogs.com/shuaixf/archive/2011/11/29/2267863.html]]></content>
      <categories>
        <category>其他软件</category>
        <category>虚拟机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读《富爸爸 穷爸爸》]]></title>
    <url>%2F2019%2F08%2F25%2F%E8%AF%BB%E3%80%8A%E5%AF%8C%E7%88%B8%E7%88%B8-%E7%A9%B7%E7%88%B8%E7%88%B8%E3%80%8B%2F</url>
    <content type="text"><![CDATA[富人不为钱工作P33 “生活是最好的老师。大多数时候，生活不会和你说什么，它只是推着你转，每一次推，它都像是在说：‘喂，醒一醒，我要让你学点东西。’ ” “假如你学会了生活这门课程，做任何事情你都会游刃有余。如果你学不会，生活照样会推着你转。人们通常会做两件事，一些人在生活推着他转的同时，抓住生活赐予的每个机会；而另一些人则非常生气，去与生活抗争。他们与老板抗争，与工作抗争，甚至与自己的配偶抗争，他们不知道生活同时也给了他们机会。”]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[eclipse使用]]></title>
    <url>%2F2019%2F08%2F23%2Feclipse%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[eclipse源码文件夹都会被合并到类路径下]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在eclipse中导入源码]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%9C%A8eclipse%E4%B8%AD%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[方式一： 点击图中所示位置，设置源码来源]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周阳jvm]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%91%A8%E9%98%B3jvm%2F</url>
    <content type="text"><![CDATA[minor GC一般发生在新生代，使用的是复制算法 老年代一般是由标记清除或者是由标记清除或标记整理的混合实现 内存效率： 复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单地对比时间复杂度，实际情况不一定如此） 内存整齐度： 复制算法=标记整理算法&gt;标记清除算法。 内存利用率： 标记整理算法=标记清除算法&gt;复制算法。]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux常用网络命令]]></title>
    <url>%2F2019%2F08%2F20%2Flinux%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[网络命令：write给指定用户发消息 123write 用户名信息内容#以Ctrl+D保存结束 w命令可以查看当前在线用户 网络命令：wall给所有用户发消息 12345678910wall [message]#发送广播消息last#查看目前和过去的所有登录信息lastlog#最后登录的信息lastlog -u uid#只查看此用户的登录信息traceroute www.baidu.com#显示数据包到主机间的路径netstat -tlun #查看本机监听的端口netstat -an #查看本机所有网络连接netstat -rn #查看本机路由表]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap]]></title>
    <url>%2F2019%2F08%2F19%2FConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap采用“锁分段”机制，每个段都是一个独立的锁]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些Linux命令]]></title>
    <url>%2F2019%2F08%2F08%2F%E4%B8%80%E4%BA%9BLinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[centos中本没有apt-get命令，需要手动安装 centos切换root用户 12[hsk@localhost 桌面]$ su密码： centos中安装软件——yum12#有个前提是yum安装的软件包都是rpm格式的yum install 软件包名#需要下载 yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断； 删除的命令是 1yum remove ~ 用yum查询想安装的软件 我们常会碰到这样的情况，想安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时yum的查询功能就起作用了 12yum search keywordyum info packagename#获取包的相关信息 centos安装软件——rpm小技巧yum用于安装软件包及其依赖，rpm用来安装特定软件包，当发生某两个软件包之间的冲突时不妨考虑一下已安装包的更新 12rpm -U 软件包名称yum update 软件包名称 centos6 添加开机自启动转自https://www.jianshu.com/p/ca79093c488e 1chkconfig sshd on 虚拟机设置默认路由命令：gw表示网关，后面的参数需要是真实机的网关 1route add default gw 192.168.0.1 在克隆Linux虚拟机时这些文件需要注意 1234-&gt;vim /etc/udev/rules.d/70-persistent-net.rules #-&gt;vim /etc/sysconfig/network-scripts/ifcfg-eth0 #网络接口相关配置-&gt;vim /etc/sysconfig/network #配置主机ip映射-&gt;vim /etc/init.d/network ifconfig命令加-a可以查看所有可用网络接口 下载命令Linux的下载指令有curl和wget curl：使用方法如下 12#curl [OPTION] [URL]curl http://pjreddie.com/media/files/darknet.conv.weights 通过-o/-O选项保存下载的文件到指定的文件中：-o：将文件保存为命令行中指定的文件名的文件中-O：使用URL中默认的文件名保存文件到本地 1curl -O http://pjreddie.com/media/files/darknet.conv.weights 使用-C断点续传 12345678# 当文件在下载完成之前结束该进程$ curl -O http://pjreddie.com/media/files/darknet.conv.weights############## 18.5%# 通过添加-C选项继续对该文件进行下载，已经下载过的文件不会被重新下载curl -C - -O http://pjreddie.com/media/files/darknet.conv.weights############### 18.5%原文链接：https://blog.csdn.net/u014540717/article/details/53097374 wget： wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 同时支持HTTP，HTTPS和FTP协议 12#wget [OPTION] [URL]wget http://pjreddie.com/media/files/darknet.conv.weights -c是断点续传 内核相关1234yum list kernel //查看当前内核可更新版本uname -sr //查看当前内核版本cat /etc/redhat-release //查看系统版本strings /lib64/libc.so.6 | grep GLIBC_ //最高支持glibc版本 文件编码相关：12在Vim中可以直接查看文件编码:set fileencoding]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[尚硅谷周阳的mysql脑图]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%91%A8%E9%98%B3%E7%9A%84mysql%E8%84%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[今天在看周阳老师授课时写了脑图，众所周知，脑图可是学习利器之一啊，于是就在网上到处翻，最后终于是找到了，无奈本人的MindManager即将过期，所以把脑图转了html文档，不想要安装MindManager的可以点此下载。 由于搭建博客用的框架对会自动对html文档进行修改（神烦）以至于无法正常加载，所以上传的文件是无后缀的，下载后需要改为html后缀，之后可以直接用浏览器打开 这里是原版脑图 注意： ​ github部署是html文件名需要非中文无空格]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浮点错误]]></title>
    <url>%2F2019%2F08%2F04%2F%E6%B5%AE%E7%82%B9%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[浮点错误: 您的程序运行时发生浮点错误，比如遇到了除以 0 的情况所以发生浮点错误应该考虑程序中： 是否可能出现了一个数除以0的情况 是否可能出现了一个数取余0的情况 是否发生了数据溢出而导致的除以0或者取余0的情况 转自https://blog.csdn.net/liuchuo/article/details/52134091]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>踩坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql之select]]></title>
    <url>%2F2019%2F08%2F04%2Fmysql%E4%B9%8Bselect%2F</url>
    <content type="text"><![CDATA[语法: 1select 查询列表 from 表名; 特点： 1.查询列表可以是：表中的字段，常量值、表达式、函数 2.查询的结果是一个虚拟的表格 12SELECT `first_name`,`last_name`,`phone_number` FROM employees;#查询列表中的·着重号去掉无影响，他可以用来判别有些以mysql关键字命名的属性名 按F9执行选中的select语句 select中起别名优点 便于理解 若要查询的字段有重名的情况，取别名可以避免 语法如下： 12341. SELECT 100%98 AS 结果;2. SELECT 100%98 结果;#省略as3. SELECT salary AS &quot;out put&quot; FROM employees;#当要起的别名中含有关键字时，记得加上双引号（推荐）或单引号 判断函数ifnull 12SELECT IFNULL(`commission_pct`,0.00) FROM employees;#若为空，显示为0]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原子变量与CAS算法]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8ECAS%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[此花不与群花比 原子性问题原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行 一些常见的代码，如i++并不是原子操作，多线程并发执行时极易出现错误 1234567public static void main(String[] args) &#123; // TODO Auto-generated method stub AtomicDemo ad=new AtomicDemo(); for(int i=0;i&lt;20;i++)&#123; new Thread(ad).start(); &#125;&#125; 1234567891011public class AtomicDemo implements Runnable&#123; private int serialNumber=0; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(getSerialNumber()); &#125; public int getSerialNumber()&#123; return serialNumber++; &#125;&#125; jdk1.5后java.util.concurrent.atomic包提供了许多包装器用于原子的整数浮点数等 它们内部使用了volatile保证内存可见性， CAS（Compare-And-Set）算法保证数据操作的原子性，CAS算法是硬件对于并发操作共享数据的支持 CAS算法包含了三个操作数： 内存值 V；预估值 A；更新值 B；当且仅当V == A时，V=B，否则什么也不做 1234567891011public class AtomicDemo implements Runnable&#123; private AtomicInteger serialNumber=new AtomicInteger(); @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(getSerialNumber()); &#125; public int getSerialNumber()&#123; return serialNumber.getAndIncrement();//等价于i++ &#125;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字与内存可见性]]></title>
    <url>%2F2019%2F08%2F04%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[内存屏蔽在某些情况下多个线程共享的数据段，会出现内存屏蔽，即其中一个线程已经对该共享数据做了修改，可其他线程却一直没有进行数据更新（比如在使用while(true){}循环时，由于此结构调用了较为底层的代码，执行效率极高，以至于没有更新数据段的机会） 看个栗子 1234567891011121314151617package juc;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ThreadDemo td=new ThreadDemo(); new Thread(td).start(); while(true)&#123; if(td.isFlag())&#123; System.out.println("-------------");//此段代码无法被执行 break; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324package juc;public class ThreadDemo implements Runnable&#123; private boolean flag=false; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; flag=true; System.out.println("flag="+isFlag()); &#125;&#125; 输出结果如下 解决方法 同步锁（效率很低） 123456789while(true)&#123; synchronized (td)&#123;//可以保证数据的一个及时更新 if(td.isFlag())&#123; System.out.println("-------------"); //此段代码现在可以被执行 break; &#125; &#125;&#125; 使用volatile关键字，当多个线程操作共享数据时，可以保证内存中的数据可见，为实例域的同步访问提供了一种免锁机制 1private volatile boolean flag=false; 不过要注意的是，volatile不具备“操作互斥性”，且不提供原子操作]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[codeblock安装血泪史]]></title>
    <url>%2F2019%2F08%2F03%2Fcodeblock%E5%AE%89%E8%A3%85%E8%A1%80%E6%B3%AA%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[其实之前我用的C/C++IDE是Dev C++（此前一直以为IDE和编译器如gcc，和g++是一个东西，很久很以前，自己曾经还是明白这其中的弯弯绕的，时间太长给忘了），之后在网上发现比较精妙的C程序后，想调试一下，结果发现调试不了。 当时以为是Dev的问题，就去下载codeblock，结果发现也是能编译运行不能调试，有以下错误 123gcc: Internal error: Aborted (program collect2)Please submit a full bug report.See &lt;URL:http://www.mingw.org/bugs.shtml&gt; for instructions. 那时已经有点明白是编译器出了问题，可是不知道如何解决，只能去网上Google，在网上codeblock的论坛上扒了好久，终于发现有个和我遇到同样问题的人，可是管理却说这不是codeblock论坛的负责范畴（可能是因为太简单，不屑于解答吧），并亮出了一份发帖规范（汗），惹不起惹不起。 我把Dev C++和codeblock卸载重装了无数遍，同时接着在网上扒拉，发现每次安装codeblock时他都会自动寻找本机所安装的其他编译器（Dev 中有一个，还有个在C盘根目录下），之后倒是不报编译器error了，因为他已经没有编译器了。。 后来明白codeblock有的版本自带编译器（其安装目录有MinGW文件夹，可去此网站下载），有的不自带编译器，若自带编译器的话还是提示找不到编译器，可按以下步骤： 点开Settings下的Compiler 找到Toolchain executables选项卡，设置Compiler’s installation directory为你的codeblock的MinGW文件夹 记得把下面的编译器路径也改改 点击保存，重启codeblock，更改就会生效了 可是安装完之后，发现依然无法调试是下面这个错误 1234ERROR: You need to specify a debugger program in the debuggers&apos;s settings.(For MinGW compilers, it&apos;s &apos;gdb.exe&apos; (without the quotes))(For MSVC compilers, it&apos;s &apos;cdb.exe&apos; (without the quotes)) 呵，瞧我这暴脾气，又去google了一下 这时需要打开Settings里的Debugger 需要把下面这个路径设置为你的MinGW下的gdb.exe所在路径（若是没有，可去此网站 下载一个） 有些编译环境的中文不能编译，需要新建项目才能编译哦 再次调试终于没有问题了，真心累呀（codeblock调试方法见下篇）]]></content>
      <categories>
        <category>其他软件</category>
        <category>codeblock</category>
      </categories>
      <tags>
        <tag>踩坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql常用命令]]></title>
    <url>%2F2019%2F08%2F03%2Fmysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mysql命令12345show tables from databasename;#在当前数据库中查看其他数据库中内容select database();#显示当前操作数据库select version();-- 查看当前数据库版本show databases;#查看所有已建数据库show tables;#查看当前数据库中所有表 cmd命令 12mysql --version//查看当前数据库版本mysql -V//同上 mysql的语法规范 不区分大小写，但建议关键字大写，表名、列名小写 每条命令用分号结尾 注释 单行注释：#注释内容 单行注释：– 注释内容 多行注释：/ 注释内容 / 查看mysql字符集 1show VARIABLES like &apos;character%&apos;; mysql 排序后加序号 1234567SET @i := 0;SELECT @i := @i + 1 AS `order`,e.* FROM employees e WHERE hiredate= (SELECT MAX(hiredate) FROM employees);或者照下面做select ROW_NUMBER() OVER (ORDER BY a.hiredate ASC) AS XUHAO,a.* from employees a; 看个栗子 12345678910111213SELECT * FROM employees WHERE employees.hire_date=( SELECT hh.hire_date FROM ( SELECT ROW_NUMBER() OVER (ORDER BY e.hire_date ASC) AS orde,e.hire_date FROM employees e GROUP BY e.`hire_date` ) hh WHERE hh.orde+2=( SELECT COUNT(hh.orde) FROM ( SELECT ROW_NUMBER() OVER (ORDER BY e.hire_date ASC) AS `orde`,e.hire_date,COUNT(*) FROM employees e GROUP BY e.`hire_date` ) hh ) ); 查看及设置当前的隔离级别 12345SELECT @@transaction_isolation;SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;#设置当前会话的隔离级别SET GLOBAL SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;#设置全局的隔离级别 查看所有表中加的锁 1show open tables;#加了锁的表只能处理当前表，直到释放锁]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql服务的启动与停止]]></title>
    <url>%2F2019%2F08%2F03%2Fmysql%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%81%9C%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[mysql服务的启动与停止首先右击我的电脑，点击管理 而后找到服务与应用程序中的服务 找到mysql服务，右击可以查看状态，并控制启动和停止 如果觉得这样查找过于麻烦可以使用命令行方式，不过要记得切换管理员呀 12-&gt;net start mysql80//启动-&gt;net stop mysql80//停止 mysql的登录命令行方式12mysql -h主机名 -P端口号 -u用户名 -p密码//可以连接远程数据库mysql -u用户名 -p密码//若是本地的，可以简写，默认本机localhost，加默认端口号]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C内存分配函数]]></title>
    <url>%2F2019%2F07%2F30%2FC%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[C双重指针与参数传递]]></title>
    <url>%2F2019%2F07%2F30%2FC%E5%8F%8C%E9%87%8D%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C的单链表的实现]]></title>
    <url>%2F2019%2F07%2F30%2FC%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[单链表是线性表的链式实现，插入和删除非常方便，可也失去了顺序表可随机存取的优点 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;typedef int ElemType; typedef struct LNode&#123; ElemType data; //1. struct LNode *next; LNode *next; //以上两种定义方式均可声明成功 //LinkList next;此种不行 &#125;*LinkList,LNode;void InitList(LinkList &amp;L,int capacity) &#123;//用给定的容量初始化一个单链表 L-&gt;data=capacity; LinkList node=L; //ElemType data=0; while(capacity--)&#123; node-&gt;next=(LinkList)malloc(sizeof(LNode)); node=node-&gt;next; scanf("%d",&amp;(node-&gt;data)); node-&gt;next=NULL; //对于为空的指针一定要初始化为NULL &#125;&#125;void ListTraverse(LinkList L,void (*visit)(int))&#123;//对链表中的每个元素逐个调用visit函数，直至遍历结束 LinkList node=L; // for(;node!=NULL;node=node-&gt;next)// visit(node-&gt;data);// 此种或者按以下方式访问 while(node)&#123; visit(node-&gt;data); node=node-&gt;next; &#125;&#125;void visit(int data)&#123; printf("data为：%d\n",data);&#125;int main()&#123; LinkList head=(LinkList)malloc(sizeof(LNode)); InitList(head,5); ListTraverse(head,&amp;visit); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[typedef与struct]]></title>
    <url>%2F2019%2F07%2F30%2Ftypedef%E4%B8%8Estruct%2F</url>
    <content type="text"><![CDATA[####]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[资源包]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%B5%84%E6%BA%90%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文转自https://blog.csdn.net/PacosonSWJTU/article/details/50639756 java国际化——资源包相关problem+solution problem： 当本地化一个应用时， 可能会有大量的消息字符串， 按钮标签和其它的东西需要被翻译； solution： 你会希望在外部定义消息字符串， 通常称之为资源。 在java中， 需要使用属性文件来设定字符串资源，并为其它类型的资源实现相应的类； 定位资源包当本地化一个应用时，会制造出很多资源包。每个包都是一个属性文件或者是一个描述了与 locale 相关的项的类。对于每一个包， 都要为所有你想要支持的 locale 提供相应的版本；想要对这些包使用一种统一的命名规则： 包名语言国家；包名_语言；来命名所有和语言相关的资源。 最后，作为后备， 可以把默认资源放到一个没有后缀的文件中； 可以用下面的命令加载一个包： 1ResourceBundle resource = ResourceBundle.getBundle(bundleName, currentLocale); getBundle 方法试图加载匹配当前 locale 定义的语言和国家的包。如果失败， 通过依次放弃国家和语言来继续进行查找， 然后同样的查找被应用于默认的 locale； 也就是说， getBundle 方法试图加载以下的包： 1234567（1）包名当前locale的语言当前Locale的国家_当前Locale的变量； （2）包名当前locale的语言当前Locale的国家； （3）包名_当前locale的语言； （4）包名默认locale的语言默认Locale的国家_默认Locale的变量； （5）包名默认locale的语言默认Locale的国家； （6）包名_默认locale的语言； （7）包名； 总之， java 的资源包机制会自动定位与给定的locale 匹配得最好的项可以很容易地吧越来越多的本地化信息加到已有的程序中： 你需要做的只是增加额外的资源包； 利用属性文件进行国际化 对字符串进行国际化是很直接的， 你可以吧字符串放到一个属性文件中， 典型的 属性文件内容如下： 123computeButton=Rechnen colorName=black defaultPaperSize=210X297 然后利用以上提到的规则去命名你的属性文件 123MyprocStrings.properties MyprocStrings_en.properties MyprocStrings_de_DE.properties 你可以直接加载包：如 1ResourceBundle bundle = ResourceBundle.getBundle(“MyProcStrings”, locale); 要查找一个具体的字符串，可以调用： 1string str = bundle.getString(“colorName”); **Warning**: 存储属性的文件都是ASCII文件， 如果你需要将 Unicode 字符放到属性文件中， 那么请用\uxxxx 编码方式对它们进行编码。 你可以使用 native2ascii 工具来产生这些文件； 看个利用.properties文件进行国际化的荔枝： for souce code, please visit : https://github.com/pacosonTang/core-java-volume/tree/master/coreJavaAdvanced/chapter5/ResourceBundle_Properties key source code at a glance: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PropertiesDemo&#123; // 显示与给定Locale相关的.properties文件中的key对应的value static void displayValue(Locale locale, String key) &#123; ResourceBundle labels = ResourceBundle.getBundle(&quot;LabelBundle&quot;, locale); String value = labels.getString(key); System.out.println(&quot;locale = &quot; + locale.getDisplayName() + &quot;, key = &quot; + key + &quot;, value = &quot; + value); &#125; // 迭代与给定Locale相关的.properties文件中的keys static void iterateKeys(Locale locale) &#123; ResourceBundle labels = ResourceBundle.getBundle(&quot;LabelBundle&quot;, locale); Enumeration&lt;String&gt; keys = labels.getKeys(); while(keys.hasMoreElements()) &#123; String key = keys.nextElement(); String value = labels.getString(key); System.out.println(&quot;locale = &quot; + locale.getDisplayName() + &quot;, key = &quot; + key + &quot;, value = &quot; + value); &#125; &#125; public static void main(String[] args) &#123; Locale.setDefault(Locale.ENGLISH); Locale[] supportedLocales = &#123; Locale.CHINA, Locale.GERMAN, Locale.ENGLISH &#125;; System.out.println(&quot;=== the output of method displayValue is as follows: ===\n&quot;); for (int i = 0; i &lt; supportedLocales.length; i++) &#123; displayValue(supportedLocales[i], &quot;s2&quot;); &#125; System.out.println(); System.out.println(&quot;=== the output of method iterateKeys is as follows: ===\n&quot;); iterateKeys(supportedLocales[0]); &#125;&#125; relative printing results as follows: 利用包类进行国际化 为了提供字符串外的资源，需要定义类， 它必须扩展于 ResourceBundle 类， 应该使用标准的命名规则来命名你的类， 如：（干货——资源绑定类引入原因——为了对字符串外的资源进行国际化，需要定义资源绑定类）（干货——包类的命名规则） 123MyprogResources.java MyprogResources_en.java MyprogResources_de_DE.java 你可以使用 与 加载属性文件相同的getBundle 方法来加载这个类： （干货——加载资源绑定类与资源包的方法相同，即getBuddle） 1ResourceBundle bundle = ResourceBundle .getBundle(“MyprogResources”, locale); Warning） 当搜索包时， 如果在类中的包和在属性文件中的包中都存在匹配， 优先选择类中的包； 每一个资源绑定类都实现了一个查询表。 你需要为每一个你想定位的设置都提供一个关键字字符串， 使用这个字符串来提取相应的设置， 如； 12Color background = (Color) bundle.getObject(“background”); double[] papersize = (double[]) bundle.getObject(“defaultSize”); 使用资源绑定类的最简单方法就是 继承 ListReourceBundle类； （干货——使用资源绑定类的最简单方法就是 继承 ListReourceBundle类） ListReourceBundle： 让你把所有资源都放到一个对象数组并提供查找功能， 请遵循以下框架代码： 12345678910public class bundleName_language_country extends ListResourceBundle &#123; private static final Object[][] contents = &#123; &#123;key1, value1]; &#123;key1, value1]; … &#125; public Object[][] getContents() &#123; return contents ; &#125; &#125; 看个栗子 12345678910public class ProgramResource_de extends ListResourceBundle&#123; private static final Object[][] contents = &#123; &#123;&quot;background&quot;,Color.black]; &#123;&quot;defaultPaperSize&quot;, new double[]&#123;210, 297&#125;&#125; ... &#125; public Object[][] getContents() &#123; return contents ; &#125;&#125; 或者， 你的资源绑定类可以扩展 ResourceBundle 类。 然后需要实现两个方法， 一个是枚举所有键，二是用给定的键查找相应的值 123Enumeration&lt;String&gt; getKeys();Object handleGetObject(String key);ResourceBundle 类的 getObject 方法会调用你提供的 handleGetBundle 方法； 看个利用.class文件进行国际化的荔枝： for souce code, please visit : https://github.com/pacosonTang/core-java-volume/tree/master/coreJavaAdvanced/chapter5/ResourceBundle_Class key source code at a glance: 123456789101112131415161718192021222324252627282930public class ListResourceBundleDemo&#123; // 显示与给定Locale相关的.properties文件中的key对应的value static void displayValue(Locale locale) &#123; ResourceBundle stats = ResourceBundle.getBundle("com.corejava.chapter573.StatsBundle", locale); Integer gdp = (Integer) stats.getObject("GDP"); Integer population = (Integer) stats.getObject("Population"); Double literacy = (Double)stats.getObject("Literacy"); System.out.println("locale = " + locale.getDisplayName() + ", gdp = " + gdp + ", population = " + population + ", literacy = " + literacy); &#125; public static void main(String[] args) &#123; Locale.setDefault(Locale.US); Locale[] locales = &#123; new Locale("en", "CA"), new Locale("de", "DE"), new Locale("zh", "CN") &#125;; for (int i = 0; i &lt; locales.length; i++) &#123; displayValue(locales[i]); &#125; &#125;&#125; 3. relative printing results as follows: ![](https://bigengzhe.github.io/images/20160206083133641)]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>国际化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文本文件和字符集]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[文本文件和字符集 java是完全基于Unicode的，但是 os 一般有它们自己的字符编码，比如在 美国是 ISO-8859-1（8位代码，有时候也称为 ANSI 代码）， 在台湾是 Big5； 当把数据保存到一个文本文件中时，应该照顾到本地的字符编码，这样，用户就可以用它们的其他程序打开这个文本文件。 字符编码是在 FileWriter 的构造器中指定的： out = newFileWriter(filename, “ISO-8859-1”)； problem：遗憾的是， 目前，locale 和字符编码间没有任何联系。 比如， 你的 用户选择的是台湾的locale_zh_TW， 但是在 java中并没有提供任何方法来告诉你用 Big5 字符编码是最恰当的； 源文件的字符编码 作为 coder， 要牢记你需要与java 编译器进行交互： 这种交互需要通过本地系统的工具来完成； 使用中文版的记事本来写你的java 源代码文件， 但这样写出来的源代码不能随处使用；因为它们使用的是本地的字符编码；只有编译后的class 文件才能随处使用， 因为它们会自动地使用 “modified UTF-8” 编码来处理标识符和字符串。 这意味着即使在程序编译和运行时，依然有3种字符编码参与其中： 源文件： 本地编码； 类文件： modified UTF-8； 虚拟机： UTF-16； 为了使你的源文件到处都可用， 必须使用普通 的 ASCII 编码： 也就是说， 你需要将所有 非ASCII 字符转换成等价的 Unicode 编码； jdk 有一个工具 native2ascii ：可以用它来将本地字符编码转换为 普通 的 ASCII ， 这个工具直接将输入中的每一个非 ASCII 字符替换为 跟尾儿 \u 加上四位 16进制数字的Unicode值；（干货——native2ascii 工具的作用） 如何使用 native2ascii 工具：native2ascii Myfile.java Myfile.temp 用 -reverse 进行逆向转换：native2ascii -reverse myfile.temp myfily.java 用 -encoding 选项指定另一种编码：编码的名字必须是 编码表所列出来的名字之一， 如： native2ascii -encoding Big5 myfile.java myfile.temp 看个栗子 native2ascii HelloWorld.java HelloWorld.temp native2ascii -encoding Big5 HelloWorld.java HelloWorldTW.temp native2ascii -reverse HelloWorld.temp Reverse.java 转自https://blog.csdn.net/PacosonSWJTU/article/details/50636153]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>国际化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[消息格式化]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[消息格式化java类库中有个MessageFormat类，用来格式化带变量的文本 1234String msg=MessageFormat.format("On &#123;2&#125;,a &#123;0&#125; destroyed &#123;1&#125; houses and caused &#123;3&#125; of damage." ,"hurricane",99, new GregorianCalendar(1999,0,1).getTime(), 10.0E8); 在上面这个例子中，占位符{0}被“hurricane”替换，{1}被99替换，等等 除此之外，上面这个例子还可以进一步被完善 123"On &#123;2,date,long&#125;,a &#123;0&#125; destroyed &#123;1&#125; houses and caused &#123;3,number,currency&#125; of damage."//可以被转换成"On January 1,1999,a hurricane destroyed 99 houses and caused $100,000,000 of damage." 占位符后面跟的是type和style，它们之间用逗号隔开。类型有以下 1234numbertimedatechoice 如类型是number，style可以是 123integercurrencypercent 若类型是time或date 1234shortmediumlongfull 附： 静态的MessageFormat.format方法只能使用默认的locale对值进行格式化，如果想用任意的locale进行格式化，可以这样做 123MessageFormat mf=new MessageFormat(pattern,loc);String msg=mf.format(new Object[] &#123;....&#125;);//Object[]中是即将被格式化的值 消息格式化之选择格式problem： “on {2}, a {0} destoryed {1} houses and caused {3} of damage. “， 如果用“earthquake” 来替换代表灾难的占位符{0}， 那么在英语中，这句话就不正确了，因为，on january 1, 1999, a earthquack destoryed， 因为 earthquake 的首字母是 e， 冠词是an 而不是 a；solution：我们希望消息能随占位符发生变化， 这样就能根据具体的值形成 123no houses one house 2 houses choice 的格式化选项就是为了这个目的而设计的。 一个选择格式是由一个序列对构成的， 每一对都包括 ： 一个下限 + 一个格式字符串； 下限和格式字符串由一个 # 符号分割， 对与对之间由 符号 | 分割；如：{1， choice，0#no houses | 1#one house|2#{1} houses}0#no houses ： 0 是 下限， # 是分割符， no houses 是格式化字符串；（注意 0， 1， 是下限，最低限度） 可以使用 &lt; 符号来表示如果替换值严格小于下限，则选中这个选择项；也可以使用 ≤ （unicode中代码是 u\2264）来实现 和 # 相同 的效果。如果愿意的话，甚至可以将第一个下限值定义为 -∞（unicode 编码是 -\u221E） 1-∞ &lt; no houses |0 &lt; one house |2≤&#123;1&#125; houses； 或者使用 Unicode 转移字符： -\u221E &lt; no houses | 0 &lt; one house |2\u2264 &#123;1&#125; houses； 看个栗子 1String pattern = “on &#123;2, date, long&#125;, &#123;0&#125; destoryed &#123;1, choice, 0#no houses|1#one house|2#&#123;1&#125; houses&#125;” + “and caused &#123;3, number, currency&#125; of damage”;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>国际化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序java中的compareTo方法是用Unicode字符来决定顺序的。对于特定语言的专属字符，Unicode值可能特别大，我们可以使用以下方法来改善排序效果 123Locale loc=...;Collator coll=Collator.getInstance(loc);if(coll.compare(a,b)&lt;0)&#123;&#125; Collator类实现了Comparator接口，它的排序方法照顾到了语言特性。同时，我们还可以传一个排序器对象到Collection.sort方法中来对一组字符串进行排序 1Collections.sort(strings.coll); 排序强度1）字符间的差别： 分为首要的、其次的、和再次的；如， A 和 Z 之间的差别被归为首要的， 而 A 和 A（头顶小圆圈）的差别是其次的， 而A 和 a 是再次的； 2）排序强度设置： 2.1）如果将强度设为 Collator.PRIMARY：那么排序器将只关注 primary级的差别； 2.2） 如果将强度设为 Collator.SECONDARY： 那么排序器将关注 primary + secondary 级的差别， 也就是说，两个字符串在“secondary”或“tertiary”强度下很容易被区分开； 2.3） 如果将强度设为 Collator.IDENTICAL：则不允许有任何差异；这种设置在与排序器的第二种具有相当技术性的设置，即分解模式，联合使用时，就会显得特别有用； 排序器分解模式1）分解： 即一个字符对应多个Unicode编码；如A（头顶一个圆圈）可以是Unicode字符 U+00C5， 或者表示为 普通的A（U+0065）后跟一个圆圈；2）Unicode标准： 对字符串定义了四种范化形式： D， KD， C 和 KC；3）我们可以选择排序器所使用的范化程度（如下表所示）： 3.1）NO_DECOMPOSITION（不分解）： Collator.NO_DECOMPOSITION 表示不对字符串做任何范化，这时选项处理速度较快， 但是对于以多种形式表示字符的文本就显得不适用了； 3.2）CANONICAL_DECOMPOSITION（规范分解）： 默认值Collator.CANONICAL_DECOMPOSITION 使用 范化形式D， 这对于包含重音但不包含连字的文本是非常有用的形式； 3.3）完全分解： 最后是使用 范化形式KD的完全分解； 4）让排序器去多次分解一个字符串是很浪费时间的： getCollationKey方法： 返回一个 CollationKey对象， 可以用它来进行更深入的，更快速的比较操作，下面是一个荔枝： （干货——让排序器去多次分解一个字符串是很浪费时间的，故而引入了 getCollationKey方法， CollationKey==排序键） 123String a = …; CollationKey key = coll.getCollationKey(a); if(key.compareTo(coll.getCollationKey(b)) == 0) // fast comparison 5）最后，有可能在你不需要进行排序时， 也希望将字符串转换为它们的范化形式。java.text.Normalizer 类实现了 对范化的处理， 如： 12String name = “augs”; String normalized = Normalizer.normalize(name, Normalizer.Form.NFD)； // use normalization from D 6）看个荔枝（为排序器设置排序强度和为排序器设置分解模式）： 1234567891011121314151617181920212223public static void main(String[] args) &#123; //为排序器设置排序强度 Collator collator = Collator.getInstance(Locale.US); collator.setStrength(Collator.PRIMARY);// 强度为 primary(主要的) out.println(collator.compare("Able", "able")); // return 0(equal) collator.setStrength(Collator.SECONDARY);// 强度为secondary(次要的) out.println(collator.compare("Able", "able")); // return 0(equal) collator.setStrength(Collator.IDENTICAL);// 强度为 Identical(再次的 == 分解模式) out.println(collator.compare("Able", "able")); // return 1(unequal) // // over //为排序器设置分解模式 out.println("\u00E1"); collator.setDecomposition(Collator.NO_DECOMPOSITION); // 设置为不分解模式 out.println(collator.compare("\u00E1", "a")); collator.setDecomposition(Collator.FULL_DECOMPOSITION); // 设置为完全分解模式 out.println(collator.compare("\u00E1", "a")); &#125; compare是大序在前]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>国际化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数字格式]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数字数字和货币的格式是高度依赖于locale的，java类库提供了一个格式器对象的集合，可以对java.text包中的数字值进行格式化和解析。步骤如下 使用上一节的方法获得一个locale对象 使用一个工厂方法得到一个格式器对象 使用这个格式器对象来完成格式化和解析工作 工厂方法共有三个：getNumberInstance、getCurrencyInstance和getPercentInstance。他们分别返回可以关于数字、货币和百分比进行格式化和解析的对象 相反的，如果想读取一个按照某个locale规定而输入的数字，那么就需要使用parse方法，parse方法能够处理小数点和分隔符以及其他语言中的数字。 parse返回类型是抽象的Number。这是一个Double或Long的包装器，这取决于被解析的数字是否是浮点数，如果两者都可以接受，可以使用Number类中的doubleValue方法来读取被包装的数字 请注意，由getXxxInstance工厂方法返回的类只是抽象类NumberFormat类的一个子类，工厂方法知道如何定位属于特定的locale对象。 可以用静态的getAvailableLocales方法得到一个当前所支持的locale的对象列表。这个方法返回一个locale对象数组，从中可以获得针对它们的数字格式器对象。 示例程序如下 1234567891011121314151617public void testNumberFormat()throws Exception&#123; /*for( Locale locale : NumberFormat.getAvailableLocales())&#123; System.out.println(locale.getDisplayName(locale)); &#125; //遍历可用locale，并用其专属locale输出*/ Locale loc=new Locale("de","DE"); NumberFormat currFmt=NumberFormat.getCurrencyInstance(loc); //用给定的locale实例化转换器 double amt=123456.78; String result=currFmt.format(amt); System.out.println(result); NumberFormat fmt=NumberFormat.getNumberInstance(loc); //用给定的locale实例化解析器，从字符串中用特定的loc提取数字 Number input = fmt.parse(result); double x=input.doubleValue(); System.out.println(x);&#125; 运行结果： 货币虽然我们可以使用NumberFormat.getCurrencyInstance方法格式化货币，可是在有些时候它不太灵活，只能针对一种locale进行格式化。假设你为一个美国客户准备了一张货物单，上面的货物金额有的是用美元表示的，有的是用欧元。 123NumberFormat format1 = NumberFormat.getCurrencyInstance(Locale.US); NumberFormat format2 = NumberFormat.getCurrencyInstance(Locale.GERMANY); //这样一来，发票会很奇怪。 有些金额的格式是 $100，而另一些如 €100.00 这时，可以使用Currency类 可以通过将一个货币标识符传给静态的Currency.getInstance方法来得到一个Currency对象，然后对每个格式器都调用setCurrency方法 12NumberFormat euroFormatter = NumberFormat.getCurrencyInstance(Locale.US); euroFormatter.setCurrency(Currency.getInstance(“EUR”)); 日期和时间当格式化日期和时间时，需要考虑4个与locale相关的问题 月份和星期应该用本地语言来表示 年月日的顺序要符合本地习惯 公历可能不是本地首选的日期表示方法 必须要考虑本地的时区 java的DateFormat类可以用来处理这些问题。它和NumberFormat很类似 首先要得到一个locale，也可以使用默认的locale或者调用静态的getAvailableLocales方法来查看都是那些locale支持日期格式化。 lenient标志用于对日期进行宽松的解释 看个荔枝 1234567891011121314151617181920212223@Test public void testDateFormat()throws Exception&#123; Locale loc=new Locale("zh","CN"); DateFormat fmt=DateFormat.getDateInstance(DateFormat.MEDIUM, loc); /* * 与此类似的还有几个工厂方法， * getTimeInstance(timestyle,loc); * getDateTimeInstance(dateStyle,timeStyle,loc); * getDateInstance(dateStyle);使用默认locale * 为了设定想要的风格，这些工厂方法的style参数可以是以下的值 * 1.DateFormat.DEFAULT * 2.DateFormat.FULL * 3.DateFormat.LONG * 4.DateFormat.MEDIUM * 5.DateFormat.SHORT */ Date now = new Date(); String s=fmt.format(now); System.out.println(s); Date input=fmt.parse("2015-1-2"); //字符串必须按预定格式输入，否则解析错误，会抛异常 System.out.println(input); &#125; 运行结果]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>国际化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Locales]]></title>
    <url>%2F2019%2F07%2F27%2FLocales%2F</url>
    <content type="text"><![CDATA[Locale是一种专门负责国际化格式处理的类。它描述了 一种语言 一个位置（可选） 一个变量（可选） 定位了国家与语言 比如在美国是：language=English, location=United States 在德国：language=German,location=Germany 瑞士有四种官方语言（德语，法语，意大利语，里托罗曼斯语）。一个说德语的瑞士人使用的Locale是：language=German,location=Switzerland。这个locale的格式化方式和在德国使用的locale很相似；但货币值被表示成瑞士法郎而不是德国马克 如果只设定了语言，locale就无法处理和国家相关的问题，比如货币 变量只在意外情况才会用的到，定位那些某一个国家确定的语言中更为细节的问题。比如，挪威人有两个拼写集，一种是传统的：Bokmal；一种是新的：Nynorsk。传统的拼写方法将会以变量来表示。 language=Norwegian,location=Norway,variant=Bokmal java使用由国际标准化组织（ISO）所定义的编码。本地语言由小写的两个字母的代码来表示，它遵循ISO-639-1。国家代码由大写的两个字母的代码来表示，它遵循ISO-3166-1 常用语言和国家代码 构造Locale方法如下 12345678Locale german = new Locale("de");//德语Locale germanGermany=new Locale("de","DE");//德语+德国Locale germanSwitzerland=new Locale("de","CH");//德语+瑞士Locale norwegianNorwayBokmal=new Locale("no","NO","B");//挪威 同时java SE还预定义了大量locale对象，从略 和大量的语言locale，他们只设定了语言而没有位置，从略 除此之外，还有两种办法能获得locale： 使用Locale的静态getdefault方法可以获得本地操作系统默认locale对象，可以调用setDefault来改变默认的java locale；但是这种改变只会对你的程序有效，不会影响操作系统 对于所有依赖locale的类，可以返回一个它们所支持的locale数组。比如 12Locale[] supportedLocales=DateFormat.getAvailableLocales();//将返回所有DateFormat类所能处理的locale 有了locale后，可以调用其getDisplayName，它返回一个描述当前locale的字符串，如 1German (Switzerland) 不过默认是以默认的locale来表示的，这是个问题，当你的用户选择了德语作为首选语言，你应该把字符串也显示成德语，可以给German locale一个参数可以做到这一点： 12Locale loc=new Locale("de","CH");System.out.println(loc.getDisplayName(Locale.GERMAN)); 示例代码如下 12345@Test public void testLocale()&#123; Locale german=new Locale("de","CH"); System.out.println(german.getDisplayName()); &#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>国际化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LDAP]]></title>
    <url>%2F2019%2F07%2F26%2FLDAP%2F</url>
    <content type="text"><![CDATA[LDAP介绍是一类为了浏览和搜索数据而设计的特殊的数据库，目录服务是按照树状形式存储信息的，目录包含基于属性的描述性信息，并且支持高级的过滤功能。 一般来说，目录不支持大多数事务性数据库所支持的高吞吐量和复杂的更新操作，目录服务适合的业务应用在于提供大量的查询和搜索操作，而不是大量的写入。LDAP可以说是活动目录在Linux上的一个开源实现。 目录服务器通常有两个标准，分别是X.500和LDAP。X.500是ITU定义的目录标准，而LDAP是基于TCP/IP的目录访问协议，是internet上通用的目录访问协议。 LDAP是轻量级目录访问协议（Lightweight Directory Access Protocol）的缩写 LDAP实际上是X.500标准的简化版本 视频教程]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenLDAP的安装及配置]]></title>
    <url>%2F2019%2F07%2F26%2FOpenLDAP%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[OpenLDAP下载地址点击下载]]></content>
      <categories>
        <category>其他软件</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2019%2F07%2F26%2F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务我们可以将一组数据建成一个事务。当所有语句都顺利执行后，事务可以被提交，否则，如果其中某个语句遇到错误，那么事务将被回滚。 默认情况下，数据库连接处于自动提交模式，每个SQL命令一旦被执行便提交给数据库。之后便无法回滚，在使用事务时，需要关闭这个默认值 1conn.setAutoCommit(false); 然后任意多次的调用executeUpdate方法，在执行了所有命令之后调用commit方法 1conn.commit(); 如果出现错误，可以回滚 1conn.rollback(); 保存点创建一个保存点意味着稍后只需要返回这个点而不是事务的开头。 1234567891011conn.setAutoCommit(false);Statement stat=conn.createStatement();stat.executeUpdate(command1);Savepoint svpt=conn.setSavepoint();//设置保存点stat.executeUpdate(command2);if(...)conn.rollback(svpt);//回滚到保存点conn.commit();conn.releaseSavepoint(svpt);//不再需要保存点时，必须释放它 批量更新若有一个程序需要多次执行更新语句，可以使用批量更新的方法提高程序性能。在使用批量更新时，一个命令序列作为一批操作将同时被收集和提交。不过要使用DatabaseMetaData类中的，supportsBatchUpdates方法查看数据库是否支持这种特性（mysql是支持的）。 同一批操作可以包括insert、update、delete等操作，也可以是数据库定义命令，如create table和drop table。但是不能包含select操作，若有会抛异常 示例程序如下 123456789101112131415161718192021222324252627282930package transaction;import java.sql.*;import database.TestDB;public class Transaction &#123; public static void main(String[] args) throws Exception&#123; // TODO Auto-generated method stub Connection conn= TestDB.getConnection(); boolean autoCommit=conn.getAutoCommit(); conn.setAutoCommit(false); //屏蔽自动提交 Statement stat=conn.createStatement(); String sql=null; for(int i=0;i&lt;=5;i++)&#123; sql="insert into avator(id)value("+i+")"; stat.addBatch(sql); &#125; stat.executeBatch(); //批量执行 conn.commit(); //提交 conn.setAutoCommit(autoCommit); stat.close(); conn.close(); &#125;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（二）]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[多结果集在执行存储过程，或者在使用允许在单个查询中提交多个select语句的数据库时，一个查询有可能会返回多个结果集，下面是获取所有结果集的步骤： 使用execute方法来执行多个SQL语句 获取第一个结果集或更新计数 重复调用getMoreResults方法以移动到下一个结果集（这个调用会自动关闭前一个结果集） 当不存在更多的结果集时，完成操作 如果有多个结果集构成的链中的下一项是结果集，execute和getMoreResults方法将返回true，，如果在链中的下一项不是更新计数，getUpdateCount方法将返回-1 下面的循环将遍历所有的结果 123456789101112131415boolean done=false;boolean isResult=stmt.execute(command);while(!done)&#123; if(isResult)&#123; ResultSet result=stmt.getResultSet(); so something with result &#125;else&#123; int updateCount =stmt.getUpdateCount(); if(updateCount&gt;=0)&#123; do something with updateCount &#125;else done=true; &#125; isResult=stmt.getMoreResults();&#125; 获取自动生成键大多数数据库都支持某种在数据库中对行自动计数的机制。但是，不同的提供商所提供的机制之间存在着很大的差异，这些自动计数的值经常用做主键。jdbc提供了获取自动生成键的有效途径。当我们向数据库插入数据时，可以实现下面的代码来获取这个键 12345stmt.executeUpdate(insertStatement,Statement.RETURN_GENERATED_KEYS);ResultSet rs=stmt.getGeneratedKeys();if(rs.next())&#123; int key=rs.getInt(1);&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL转义]]></title>
    <url>%2F2019%2F07%2F26%2FSQL%E8%BD%AC%E4%B9%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Image对象]]></title>
    <url>%2F2019%2F07%2F26%2FImage%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[由于这个类是个抽象类，不能直接实例化，必须借助其子类，类继承结构如下 实例化方式如下 使用Toolkit类 123Toolkit.getDefaultToolkit().getImage("fiveCHessBourd.jpg");//此方法得到的是sun.awt.image.ToolkitImage对象//是一种专属实现，不属于java标准部分 ImageIO方式，这是较常用的方式 12ImageIO.read(new File("fiveCHessBourd.jpg"));//返回一个BufferedImage对象 还有一种方式是实例化Image的子类BufferedImage，不过BufferedImage并没有提供对于文件的构造器，构造方法如下 123456BufferedImage(ColorModel cm, WritableRaster raster, boolean isRasterPremultiplied, Hashtable&lt;?,?&gt; properties)//Constructs a new BufferedImage with a specified ColorModel and Raster.BufferedImage(int width, int height, int imageType)//Constructs a BufferedImage of one of the predefined image types.BufferedImage(int width, int height, int imageType, IndexColorModel cm)//Constructs a BufferedImage of one of the predefined image types: TYPE_BYTE_BINARY or TYPE_BYTE_INDEXED.]]></content>
      <categories>
        <category>我眼中的java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（一）]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读写LOB等你下课-周杰伦 LOB：在SQL中，二进制大对象称为BLOB，字符型大对象称为CLOB。 要读取LOB，需要执行select语句后，在ResultSet上调用getBlob和getClob方法，这样就可以获得Blob和Clob类型的对象。可以调用getBytes或getInputStream来从Blob中获取二进制数据。 如果你有一张保存图书封面图像的表，那么可以像下面这样获取 先mldn数据库下创建一个表 1234create table avator( id int(4) primary key auto_increment, avator mediumblob); 提示：直接用二进制字节流输出即可，不要用ImageIO+image流输出！不要用ImageIO+image流输出！不要用ImageIO+image流输出！重要的事情说三遍 关于字节流可能还有需要编码的问题，不过初次测试一切求简 示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package lob;import java.awt.Image;import java.awt.Toolkit;import java.awt.image.BufferedImage;import java.awt.image.RenderedImage;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.sql.Blob;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Arrays;import java.util.Properties;import javax.imageio.ImageIO;public class LOB &#123; public static void main(String[] args) throws Exception&#123; // TODO Auto-generated method stub insertBlob(5); selectBlob(5); &#125; public static Connection getConnection() throws SQLException, IOException &#123; Properties props = new Properties(); FileInputStream in = new FileInputStream("db.properties"); props.load(in); in.close(); String drivers = props.getProperty("driver"); if (drivers != null) System.setProperty("driver", drivers); String url = props.getProperty("url"); String username = props.getProperty("username"); String password = props.getProperty("password"); return DriverManager.getConnection(url, username, password); &#125; public static boolean insertBlob(int id)throws Exception&#123; boolean flag=false; Connection conn=getConnection(); Blob blob=conn.createBlob(); int offset=1; //the position in the BLOB value at which to start writing; the first position is 1 InputStream in=new FileInputStream("fiveCHessBourd.jpg"); OutputStream out = blob.setBinaryStream(offset); //向Blob输出 byte [] data=new byte[1024]; int len=-1; while((len=in.read(data))!=-1)&#123; out.write(data, 0, len); //System.out.println(Arrays.toString(data)); &#125; in.close(); out.close(); //一定要在sql语句执行之前关闭 String sql="insert into avator (id , avator)value(?,?)"; PreparedStatement stat=conn.prepareStatement(sql); stat.setInt(1, id); stat.setBlob(2, blob); if(stat.executeUpdate()&gt;0)&#123; //System.out.println("插入成功"); flag=true; &#125; stat.close(); conn.close(); return flag; &#125; public static void selectBlob(int id)throws Exception&#123; Connection conn=getConnection(); PreparedStatement stat=conn.prepareStatement("select avator from avator where id=?"); stat.setInt(1,id); ResultSet result = stat.executeQuery(); if(result.next())&#123; Blob blob=result.getBlob(1); //System.out.println(blob); //System.out.println(result.getBinaryStream(1)); //记住这个技巧：打印类的路径可以看到是谁为它实例化 InputStream in=blob.getBinaryStream(); byte [] data=new byte[1024]; OutputStream out=new FileOutputStream("e:/apple1.jpg"); int len=-1; while((len=in.read(data))!=-1)&#123; out.write(data, 0, len); System.out.println(Arrays.toString(data)); &#125; in.close(); out.close(); result.close(); stat.close(); conn.close(); &#125; result.close(); stat.close(); conn.close(); &#125;&#125; 输出二进制数据如下 错误的方向。。。ImageIO， 12345//RenderedImage im=(BufferedImage)ImageIO.read(new File("fiveCHessBourd.jpg"));//根据文件实例化一个Image对象，并读入内存//ImageIO.write(im, "jpg", out);//将二进制的图像文件写入BLOB中//ImageIO.write((BufferedImage)image, "jpg", new File());]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库通用组装与异常]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E7%BB%84%E8%A3%85%E4%B8%8E%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[我怎么这么好看-大张伟 分析SQL异常每个SQLException都有一个由多个SQLException对象构成的链，这些对象可以通过getNextException方法获取。我们需要用两个嵌套的循环来完全枚举所有的异常。 幸好，java 6改进了SQLException类，让其实现了Iterable&lt; Throwable&gt;接口，其iterator方法可以产生一个Iterator&lt; Throwable&gt;对象，这个迭代器可以迭代这两个链，首先迭代SQLException成因链，然后迭代下一个SQLException。我们可以使用下面的代码 123for(Throwable t : sqlException)&#123; do something with t&#125; 可以在SQLException上调用getSQLState和getErrorCode方法来进一步分析它。 数据库驱动程序可以将非致命的错误作为警告报告，我们可以从连接、语句和结果集中取出这些警告。SQLWarning类是SQLException的子类（尽管它不会被当作异常抛出）。警告也是串成链的，我们可以调用getSQLState和getErrorCode来获取有关警告的更多信息： 12345SQLWarning w=stat.getWarning();while(w!=null)&#123; do something with w w = w.nextWarning();&#125; 当数据从数据库中读出并发生意外被截断时，SQLWarning的DataTruncation子类就派上用场了，如果截断发生在更新语句中，那么DataTruncation将会被当作异常抛出。 组装数据库 连接数据库 使用sql命令打开文件 使用通用的execute方法执行每条命令。如果它返回true，则说明该命令产生了一个结果集。 如果产生了结果集，则打印结果。因为这是一个通用方法执行的结果，我们需要使用元数据来确定该结果的列数。 如果运行过程出现了异常，则打印这个异常链 关闭数据库连接 示例程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.io.*;import java.util.*;import java.sql.*;/** * Executes all SQL statements in a file. Call this program as &lt;br&gt; * java -classpath driverPath:. ExecSQL commandFile * @version 1.30 2004-08-05 * @author Cay Horstmann */class ExecSQL&#123; public static void main(String args[]) &#123; try &#123; Scanner in; if (args.length == 0) in = new Scanner(System.in); else in = new Scanner(new File(args[0])); Connection conn = getConnection(); try &#123; Statement stat = conn.createStatement(); while (true) &#123; if (args.length == 0) System.out.println("Enter command or EXIT to exit:"); if (!in.hasNextLine()) return; String line = in.nextLine(); if (line.equalsIgnoreCase("EXIT")) return; if (line.trim().endsWith(";")) // remove trailing semicolon &#123; line = line.trim(); line = line.substring(0, line.length() - 1); &#125; try &#123; boolean hasResultSet = stat.execute(line); if (hasResultSet) showResultSet(stat); &#125; catch (SQLException ex) &#123; for (Throwable e : ex) e.printStackTrace(); &#125; &#125; &#125; finally &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; for (Throwable t : e) t.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * Gets a connection from the properties specified in the file database.properties * @return the database connection */ public static Connection getConnection() throws SQLException, IOException &#123; Properties props = new Properties(); FileInputStream in = new FileInputStream("database.properties"); props.load(in); in.close(); String drivers = props.getProperty("jdbc.drivers"); if (drivers != null) System.setProperty("jdbc.drivers", drivers); String url = props.getProperty("jdbc.url"); String username = props.getProperty("jdbc.username"); String password = props.getProperty("jdbc.password"); return DriverManager.getConnection(url, username, password); &#125; /** * Prints a result set. * @param stat the statement whose result set should be printed */ public static void showResultSet(Statement stat) throws SQLException &#123; ResultSet result = stat.getResultSet(); ResultSetMetaData metaData = result.getMetaData(); int columnCount = metaData.getColumnCount(); for (int i = 1; i &lt;= columnCount; i++) &#123; if (i &gt; 1) System.out.print(", "); System.out.print(metaData.getColumnLabel(i)); &#125; System.out.println(); while (result.next()) &#123; for (int i = 1; i &lt;= columnCount; i++) &#123; if (i &gt; 1) System.out.print(", "); System.out.print(result.getString(i)); &#125; System.out.println(); &#125; result.close(); &#125;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连接到数据库]]></title>
    <url>%2F2019%2F07%2F25%2F%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[连接到数据库（非Data Source）消愁 - 毛不易 试代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package database;import java.io.FileInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Properties;public class TestDB &#123; public static void main(String[] args) &#123; ResultSet rs=null; PreparedStatement pstmt=null; try&#123; String sql="select ename from emp where empno=?"; Connection conn=getConnection(); pstmt=conn.prepareStatement(sql); pstmt.setInt(1, 1002); rs=pstmt.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString("ename")); &#125; rs.close(); pstmt.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; public static Connection getConnection() throws SQLException, IOException &#123; Properties props = new Properties(); FileInputStream in = new FileInputStream("db.properties"); props.load(in); in.close(); String drivers = props.getProperty("driver"); if (drivers != null) System.setProperty("driver", drivers); String url = props.getProperty("url"); String username = props.getProperty("username"); String password = props.getProperty("password"); return DriverManager.getConnection(url, username, password); &#125;&#125; 输出 管理连接、语句和结果集每个Connection对象都可以创建一个或多个Statement对象。同一个Statement对象可以用于多个不相关的命令和查询。但是一个Statement对象最多只能打开一个结果集，如果需要执行多个查询操作，且需要同时分析查询结果，那么必须创建多个Statement对象。 也有的数据库只允许同时存在一个激活的Statement对象。使用DatabaseMetaData类中的getMaxStatements方法可以获取JDBC驱动程序同时支持的语句对象的总数。 当时用完ResultSet、Statement、PreparedStatement或Connection对象时，应立即调用close方法，因为它们都使用了规模较大的数据结构，我们不应该等待垃圾回收器来处理它们]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[提交表单数据]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[在向Web服务器发送信息时，通常有两个命令会被用到：GET和POST。 在使用GET命令时，只需将参数附在URL的结尾处即可。格式如下 1http://host/script?parameters 其中每个参数都具有“名字=值”的形式，而且这些参数之间用&amp;字符分隔开。参数的值遵循以下规则。使用URL编码模式进行编码 保留字符A-Z、a-z、1-9以及. - * _ 用+字符替换所有的空格。 将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字。例如，若要发送街道名S. Main， 可以使用S%2e+Main，因为十六进制数2e是“.”的ASCII码值 使用POST命令时，并不需要在URL中添加任何参数，而是从URLConnection中获取输出流并将名-值对写入该流中。当然，仍然需要对这些值进行编码，并用&amp;字符将它们隔开。过程如下 1234567891011URL url= new URL("http://host/script");URLConnection connection=url.openConnection();connection.setDoOutput("true");//设置可输出PrintWriter out = new PrintWriter(connection.getOutputStream());//得到输出流out.print(name1+"="+URLEncoder.encode(value1,"UTF-8")+"&amp;");out.print(name2+"="+URLEncoder.encode(value2,"UTF-8"));//发送数据out.close();//关闭输出流 最后，调用getInputStream方法读取服务器的响应，在读取响应的过程中有个问题，若脚本运行出现错误，那么connection.getInputStream()时就会抛出一个FileNotFoundException异常，但是此时服务器依然会向浏览器发送一个错误页面。为了捕获该异常，可以将URLConnection对象转型为HTTPURLConnection类并调用它的getErrorStream方法 1InputStream err = ((HttpURLConnection)connection).getErrorStream() URLConnection对象首先向服务器发送了一个请求头，当提交表单数据时，请求头必须包含： 1Content-Type: application/x-www-form-urlencoded 而POST的请求头还必须包括内容的长度 1Content-Length: 124 请求头必须以空白行结尾，紧跟其后的才是数据部分 示例程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import java.awt.*;import java.awt.event.*;import java.io.*;import java.net.*;import java.util.*;import javax.swing.*;/** * This program demonstrates how to use the URLConnection class for a POST request. * @version 1.20 2007-06-25 * @author Cay Horstmann */public class PostTest&#123; public static void main(String[] args) &#123; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; JFrame frame = new PostTestFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); &#125; &#125;); &#125;&#125;class PostTestFrame extends JFrame&#123; /** * Makes a POST request and returns the server response. * @param urlString the URL to post to * @param nameValuePairs a map of name/value pairs to supply in the request. * @return the server reply (either from the input stream or the error stream) */ public static String doPost(String urlString, Map&lt;String, String&gt; nameValuePairs) throws IOException &#123; URL url = new URL(urlString); URLConnection connection = url.openConnection(); connection.setDoOutput(true); PrintWriter out = new PrintWriter(connection.getOutputStream()); boolean first = true; for (Map.Entry&lt;String, String&gt; pair : nameValuePairs.entrySet()) &#123; if (first) first = false; else out.print('&amp;'); String name = pair.getKey(); String value = pair.getValue(); out.print(name); out.print('='); out.print(URLEncoder.encode(value, "UTF-8")); &#125; out.close(); Scanner in; StringBuilder response = new StringBuilder(); try &#123; in = new Scanner(connection.getInputStream()); &#125; catch (IOException e) &#123; if (!(connection instanceof HttpURLConnection)) throw e; InputStream err = ((HttpURLConnection) connection).getErrorStream(); if (err == null) throw e; in = new Scanner(err); &#125; while (in.hasNextLine()) &#123; response.append(in.nextLine()); response.append("\n"); &#125; in.close(); return response.toString(); &#125; public PostTestFrame() &#123; setTitle("PostTest"); northPanel = new JPanel(); add(northPanel, BorderLayout.NORTH); northPanel.setLayout(new GridLayout(0, 2)); northPanel.add(new JLabel("Host: ", SwingConstants.TRAILING)); final JTextField hostField = new JTextField(); northPanel.add(hostField); northPanel.add(new JLabel("Action: ", SwingConstants.TRAILING)); final JTextField actionField = new JTextField(); northPanel.add(actionField); for (int i = 1; i &lt;= 8; i++) northPanel.add(new JTextField()); final JTextArea result = new JTextArea(20, 40); add(new JScrollPane(result)); JPanel southPanel = new JPanel(); add(southPanel, BorderLayout.SOUTH); JButton addButton = new JButton("More"); southPanel.add(addButton); addButton.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; northPanel.add(new JTextField()); northPanel.add(new JTextField()); pack(); &#125; &#125;); JButton getButton = new JButton("Get"); southPanel.add(getButton); getButton.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; result.setText(""); final Map&lt;String, String&gt; post = new HashMap&lt;String, String&gt;(); for (int i = 4; i &lt; northPanel.getComponentCount(); i += 2) &#123; String name = ((JTextField) northPanel.getComponent(i)).getText(); if (name.length() &gt; 0) &#123; String value = ((JTextField) northPanel.getComponent(i + 1)).getText(); post.put(name, value); &#125; &#125; new SwingWorker&lt;Void, Void&gt;() &#123; protected Void doInBackground() throws Exception &#123; try &#123; String urlString = hostField.getText() + "/" + actionField.getText(); result.setText(doPost(urlString, post)); &#125; catch (IOException e) &#123; result.setText("" + e); &#125; return null; &#125; &#125;.execute(); &#125; &#125;); pack(); &#125; private JPanel northPanel;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用URLConnection获取信息]]></title>
    <url>%2F2019%2F07%2F25%2F%E4%BD%BF%E7%94%A8URLConnection%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[使用URIConnection获取信息如果想从某个Web资源获取更多信息，那么应该使用URLConnection类，它能得到比基本的URL类更多的控制功能。 使用URLConnection类的步骤如下 调用URL类中的openConnection方法获得URLConnection对象 1URLConnection connection=url.openConnection(); 使用以下方法来设置任意的请求属性 12345678 setDoInput setDoOutputsetIfModifiedSince setUseCaches//用于命令浏览器首先检查它的缓存 setAllowUserInteraction//用于在访问有密码保护的资源时弹出对话框，以便查询用户名和口令 setRequestProperty setConnectTimeout setReadTimeout 调用connect方法连接远程资源并获取响应头信息 1connection.connect(); 与服务器建立连接后，你可以查询头信息。getHeaderFieldKey和getHeaderField两个方法列举了消息头的所有字段。getHeaderFields方法返回一个包含了消息头中所有字段的标准Map对象。为了方便使用，以下方法可以查询各标准字段 123456getContentTypegetContentLengthgetContentEncodinggetDategetExpirationgetLastModified 最后，访问资源数据。使用getInputStream方法获取一个输入流用以读入信息（这个输入流与URL类中的openStream方法返回的流相同）。 下面详细介绍一下URLConnection类中的一些方法。有几个方法可以在与服务器建立连接之前设置连接属性，其中最重要的是setDoInput和setDoOutput。在默认情况下建立的连接只有从服务器读取信息的输入流，并没有任何执行写操作的输出流。如果想获得输出流（例如，向一个Web服务器提交数据），那么可以调用： 1connection.setDoOutput 下面也可以设置请求头。请求头是与请求命令一起被发送到服务器的 12345678GET www.server.com/index.html HTTP/1.0Referer: http://www.somewhere.com/links.htmlProxy-Connection: Keep-AliveUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.4)Host: www.server.comAccept-Language: enAccept-Charset: iso-8859-1,*,utf-8Cookie: orangemilano=192218887821987 setIfModifiedSince方法用于告诉连接你只对某个特定日期以来被修改过的数据感兴趣；setUseCaches和setAllowUserInteraction这两个方法只作用于Applet； 还有一个总揽全局的方法：setRequestProperty，它可以用来设置对特定协议起作用的任何“名值对” 如果你想访问一个有保护的Web页，可以按照以下步骤操作 将用户名、冒号和口令以字符串形式连接在一起 1String input=username+":"+password; 计算上一步所得字符串的base64编码。（base64编码用于将字节流编码成可打印的ASCII字符流。） 1String encoding = base64Encode(input); 调用setRequestProperty方法，设置name参数的值为”Authorization”,value参数的值为“Base”+encoding: 1connection.setRequestProperty("Authorization","Basic "+encoding); 一旦调用了connect方法，就可以查询响应头字段 1234String key=connection.getHeaderFieldKey(n);//可以获得响应头的第n个键，其中n从1开始//还可以使用以下方法获得第n个值//String value= connection.getHeaderField(n); getHeadreFields方法可以返回一个封装了响应头字段的Map对象 1Map&lt;String,List&lt;String&gt;&gt; headerFields=connection.getHeaderFields(); HTTP响应头举例 1234567Date: Wed,27 Aug 2008 00:15:48 GMTServer: Apache/2.2.2(Unix)Last-Modified: Sun, 22 Jun 2008 20:53:38 GMTAccept-Ranges: bytesContent-Length: 4813Connection: closeContent-Type: text/html java提供了六个访问响应头的常用方法 键名 方法名 返回类型 Date getDate long Expires getExpiration long Last-Modified getLastModified long Content-length getContentLength int Content-Type getContentType String Content-Encoding getContentEncoding String 示例程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166import java.io.*;import java.net.*;import java.util.*;/** * This program connects to an URL and displays the response header data and the first 10 lines of * the requested data. * * Supply the URL and an optional username and password (for HTTP basic authentication) on the * command line. * @version 1.11 2007-06-26 * @author Cay Horstmann */public class URLConnectionTest&#123; public static void main(String[] args) &#123; try &#123; String urlName; if (args.length &gt; 0) urlName = args[0]; else urlName = "http://java.sun.com"; URL url = new URL(urlName); URLConnection connection = url.openConnection(); // set username, password if specified on command line if (args.length &gt; 2) &#123; String username = args[1]; String password = args[2]; String input = username + ":" + password; String encoding = base64Encode(input); connection.setRequestProperty("Authorization", "Basic " + encoding); &#125; connection.connect(); // print header fields Map&lt;String, List&lt;String&gt;&gt; headers = connection.getHeaderFields(); for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : headers.entrySet()) &#123; String key = entry.getKey(); for (String value : entry.getValue()) System.out.println(key + ": " + value); &#125; // print convenience functions System.out.println("----------"); System.out.println("getContentType: " + connection.getContentType()); System.out.println("getContentLength: " + connection.getContentLength()); System.out.println("getContentEncoding: " + connection.getContentEncoding()); System.out.println("getDate: " + connection.getDate()); System.out.println("getExpiration: " + connection.getExpiration()); System.out.println("getLastModifed: " + connection.getLastModified()); System.out.println("----------"); Scanner in = new Scanner(connection.getInputStream()); // print first ten lines of contents for (int n = 1; in.hasNextLine() &amp;&amp; n &lt;= 10; n++) System.out.println(in.nextLine()); if (in.hasNextLine()) System.out.println(". . ."); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * Computes the Base64 encoding of a string * @param s a string * @return the Base 64 encoding of s */ public static String base64Encode(String s) &#123; ByteArrayOutputStream bOut = new ByteArrayOutputStream(); Base64OutputStream out = new Base64OutputStream(bOut); try &#123; out.write(s.getBytes()); out.flush(); &#125; catch (IOException e) &#123; &#125; return bOut.toString(); &#125;&#125;/** * This stream filter converts a stream of bytes to their Base64 encoding. * * Base64 encoding encodes 3 bytes into 4 characters. |11111122|22223333|33444444| Each set of 6 * bits is encoded according to the toBase64 map. If the number of input bytes is not a multiple of * 3, then the last group of 4 characters is padded with one or two = signs. Each output line is at * most 76 characters. */class Base64OutputStream extends FilterOutputStream&#123; /** * Constructs the stream filter * @param out the stream to filter */ public Base64OutputStream(OutputStream out) &#123; super(out); &#125; public void write(int c) throws IOException &#123; inbuf[i] = c; i++; if (i == 3) &#123; super.write(toBase64[(inbuf[0] &amp; 0xFC) &gt;&gt; 2]); super.write(toBase64[((inbuf[0] &amp; 0x03) &lt;&lt; 4) | ((inbuf[1] &amp; 0xF0) &gt;&gt; 4)]); super.write(toBase64[((inbuf[1] &amp; 0x0F) &lt;&lt; 2) | ((inbuf[2] &amp; 0xC0) &gt;&gt; 6)]); super.write(toBase64[inbuf[2] &amp; 0x3F]); col += 4; i = 0; if (col &gt;= 76) &#123; super.write('\n'); col = 0; &#125; &#125; &#125; public void flush() throws IOException &#123; if (i == 1) &#123; super.write(toBase64[(inbuf[0] &amp; 0xFC) &gt;&gt; 2]); super.write(toBase64[(inbuf[0] &amp; 0x03) &lt;&lt; 4]); super.write('='); super.write('='); &#125; else if (i == 2) &#123; super.write(toBase64[(inbuf[0] &amp; 0xFC) &gt;&gt; 2]); super.write(toBase64[((inbuf[0] &amp; 0x03) &lt;&lt; 4) | ((inbuf[1] &amp; 0xF0) &gt;&gt; 4)]); super.write(toBase64[(inbuf[1] &amp; 0x0F) &lt;&lt; 2]); super.write('='); &#125; if (col &gt; 0) &#123; super.write('\n'); col = 0; &#125; &#125; private static char[] toBase64 = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' &#125;; private int col = 0; private int i = 0; private int[] inbuf = new int[3];&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[URL和URI]]></title>
    <url>%2F2019%2F07%2F24%2FURL%E5%92%8CURI%2F</url>
    <content type="text"><![CDATA[URL和URIURL和URLConnection类封装了大量复杂的实现细节，这些细节涉及如何从远程站点获取信息，如，可以通过传递字符串来构建一个URL对象： 1URL url=new URL(urlString); 如果只是想获得该资源的内容，可以使用URL类中的openStream方法。该方法返回一个InputStream对象，然后就可以按照一般的用法来使用这个对象了，比如用它构建一个Scanner对象： 12InputStream inStream=url.openStream();Scanner in=new Scanner(inStream); java.net包对统一资源定位符（URL）和统一资源标识符（URI）做了非常有用的区分。 URI纯粹是个句法结构，用于指定标识Web资源的字符串的各个不同部分，URL是个URI的一个特例，它包含了用于定位Web资源的足够信息。其他URI，比如 1mailto:cay@horstmann.com 则不属于定位符，因为根据该标识符我们无法定位任何数据，像这样的URI我们称之为URN（统一资源名称） 在java类库中，URI类不包含任何用于访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流，因此，URL类只能作用于那些java类库知道该如何处理的模式，例如http:、https:、ftp:、本地文件系统（file:）和jar文件（jar:） 对URI进行解析并不是可有可无的，因为它有时候会变得非常复杂。例如， 12http://maps.yahoo.com/py/maps.py?csz=Cupertino+CAftp://username:password@ftp.youserver.com/pub/file.txt URI规范给出了标记这些标识符的规则。一个URI具有以下句法： 1[scheme:]schemeSpecificPart[#fragment] 上式中，[…]表示可选部分，他：与#可以被包含在标识符内。 包含scheme：部分的URI被称为绝对URI。否则，被称为相对URI。 如果绝对URI的schemeSpecificPart不以/开头，我们就称它是不透明的。如 1mailto:cay@horstmann.com 所有绝对的透明URI和所有相对URI都是分层的。例如 12http://java.sun.com/index.html../../java/net/Socket.html#Socket() 一个分层URI的schemeSpecificPart具有以下结构: 1[//authority][path][?query] [..]表示可选 对于那些基于服务器的URI，authority部分采用以下形式 1[user-info@]host[:part]//part必须是个整数 URI类的作用之一是解析标识符并将它分解成各种不同的组成部分。你可以用以下方法读取它们 123456789getSchemegetSchemeSpecificPartgetAuthoritygetUserInfogetHostgetPostgetPathgetQuerygetFragment URI类的另一个作用是处理绝对标识符和相对标识符。如果存在一个如下的绝对URI： 1http://docs.mycompany.com/api/java/net/ServerSocket.html 和一个如下的相对URI 1../../java/net/Socket.html#Socket() 那么可以将它们合并成一个绝对URI 1http://docs.mycompany.com/api/java/net/Socket.html#Socket() 这个过程被称为相对URL的转化，与此相反的过程称之为相对化。例如，假设有一个基本URI 1http://docs.mycompany.com/api 和另一个URI 1http://docs.mycompany.com/api/java/lang/String.html 那么相对化之后的URI就是 1java/lang/String.html URI类同时支持以下两个操作 12relative=base.relativize(combined);combined=base.resolve(relative);]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[发送E-mail]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%8F%91%E9%80%81E-mail%2F</url>
    <content type="text"><![CDATA[为了发送E-mail，必须建立一个到端口25（即SMTP端口）的套接字连接。 一旦连接到服务器，就可以发送一个邮件报头（采用SMTP格式，该格式很容易生成）。紧随其后的是邮件消息。详细操作步骤如下 打开一个到达主机的套接字： 12Socket s=new Socket("mail.yourserver.com",25);PrintWriter out = new PrintWriter(s.getOutputStream()); 发送一下消息到打印流： 12345678HELO sending hostMAIL FROM:&lt;sender e-mail address&gt;RCPT TO: &lt;recipient e-mail address&gt;DATAmail message&#123;any number of lines&#125;...QUIT SMTP规范规定，每一行都要以\r再紧跟一个\n来结尾。 有些SMTP服务器并不检查信息的真实性，你可以随意填写任何你喜欢的发件人名字。 相比几下，有个更为简单的E-mail发送方式——使用JavaMail API，在JavaMail API中，你只需要简单地调用下面这个方法，就可以发送一条邮件了，该类库负责实现邮件协议、认证和附件处理等。 示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import java.awt.*;import java.awt.event.*;import java.util.*;import java.net.*;import java.io.*;import javax.swing.*;public class MailTest&#123; public static void main(String[] args) &#123; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; JFrame frame = new MailTestFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); &#125; &#125;); &#125;&#125;class MailTestFrame extends JFrame&#123; public MailTestFrame() &#123; setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT); setTitle("MailTest"); setLayout(new GridBagLayout()); add(new JLabel("From:"), new GBC(0, 0).setFill(GBC.HORIZONTAL)); from = new JTextField(20); add(from, new GBC(1, 0).setFill(GBC.HORIZONTAL).setWeight(100, 0)); add(new JLabel("To:"), new GBC(0, 1).setFill(GBC.HORIZONTAL)); to = new JTextField(20); add(to, new GBC(1, 1).setFill(GBC.HORIZONTAL).setWeight(100, 0)); add(new JLabel("SMTP server:"), new GBC(0, 2).setFill(GBC.HORIZONTAL)); smtpServer = new JTextField(20); add(smtpServer, new GBC(1, 2).setFill(GBC.HORIZONTAL).setWeight(100, 0)); message = new JTextArea(); add(new JScrollPane(message), new GBC(0, 3, 2, 1).setFill(GBC.BOTH).setWeight(100, 100)); comm = new JTextArea(); add(new JScrollPane(comm), new GBC(0, 4, 2, 1).setFill(GBC.BOTH).setWeight(100, 100)); JPanel buttonPanel = new JPanel(); add(buttonPanel, new GBC(0, 5, 2, 1)); JButton sendButton = new JButton("Send"); buttonPanel.add(sendButton); sendButton.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; new SwingWorker&lt;Void, Void&gt;() &#123; protected Void doInBackground() throws Exception &#123; comm.setText(""); sendMail(); return null; &#125; &#125;.execute(); &#125; &#125;); &#125; public void sendMail() &#123; try &#123; Socket s = new Socket(smtpServer.getText(), 25); InputStream inStream = s.getInputStream(); OutputStream outStream = s.getOutputStream(); in = new Scanner(inStream); out = new PrintWriter(outStream, true /* autoFlush */); String hostName = InetAddress.getLocalHost().getHostName(); receive(); send("HELO " + hostName); receive(); send("MAIL FROM: &lt;" + from.getText() + "&gt;"); receive(); send("RCPT TO: &lt;" + to.getText() + "&gt;"); receive(); send("DATA"); receive(); send(message.getText()); send("."); receive(); s.close(); &#125; catch (IOException e) &#123; comm.append("Error: " + e); &#125; &#125; public void send(String s) throws IOException &#123; comm.append(s); comm.append("\n"); out.print(s.replaceAll("\n", "\r\n")); out.print("\r\n"); out.flush(); &#125; public void receive() throws IOException &#123; String line = in.nextLine(); comm.append(line); comm.append("\n"); &#125; private Scanner in; private PrintWriter out; private JTextField from; private JTextField to; private JTextField smtpServer; private JTextArea message; private JTextArea comm; public static final int DEFAULT_WIDTH = 300; public static final int DEFAULT_HEIGHT = 300;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.awt.*;public class GBC extends GridBagConstraints &#123; public GBC(int gridx, int gridy) &#123; this.gridx = gridx; this.gridy = gridy; &#125; public GBC(int gridx, int gridy, int gridwidth, int gridheight) &#123; this.gridx = gridx; this.gridy = gridy; this.gridwidth = gridwidth; this.gridheight = gridheight; &#125; public GBC setAnchor(int anchor) &#123; this.anchor = anchor; return this; &#125; public GBC setFill(int fill) &#123; this.fill = fill; return this; &#125; public GBC setWeight(double weightx, double weighty) &#123; this.weightx = weightx; this.weighty = weighty; return this; &#125; public GBC setInsets(int distance) &#123; this.insets = new Insets(distance, distance, distance, distance); return this; &#125; public GBC setInsets(int top, int left, int bottom, int right) &#123; this.insets = new Insets(top, left, bottom, right); return this; &#125; public GBC setIpad(int ipadx, int ipady) &#123; this.ipadx = ipadx; this.ipady = ipady; return this; &#125;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[可中断套接字]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%8F%AF%E4%B8%AD%E6%96%AD%E5%A5%97%E6%8E%A5%E5%AD%97%2F</url>
    <content type="text"><![CDATA[当连接到一个套接字时，当前线程将会被阻塞直到建立连接或产生超时为止。通过套接字读写数据时也是一样。 在交互式的应用中，也许会考虑为用户提供一个功能，用已取消那些看似不会成功的连接，但是，当线程因套接字长时间无法响应而发生阻塞时，无法通过调用interrupt来解除阻塞。 如此，可用java.nio包提供的一个新特性——SocketChannel类中断套接字操作 1SocketChannel channel=SocketChannel.open(new InetSocketAddress(host,port)); channel并没有与之相关联的流，实际上，它所拥有的read和write方法都是通过调用Buffer对象来实现的。ReadableByteChannel接口和WritableByteChannel都声明了这两个方法。如果不想处理缓存，可以使用Scanner类来读取信息，因为Scanner有一个带ReadableByteChannel参数的构造器： 123Scanner in = new Scanner(channel);OutputStream outStream=Channels.newOutputStream(channel);//从通道获得输出流 如果线程发生中断，那么这些操作将不会陷入阻塞，而是以抛出异常的方式结束 示例程序如下 其对比了可中断套接字与阻塞套接字：服务器将连续发送数字，每发送一个数字停一下。点击两个按钮中的任何一个都会启动一个线程来连接服务器并打印输出。第一个使用可中断套接字，第二个使用阻塞套接字，启动之后，再点击取消时，可中断套接字一直工作良好，阻塞套接字却只能有效工作有限次,原因不明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239import java.awt.*;import java.awt.event.*;import java.util.*;import java.net.*;import java.io.*;import java.nio.channels.*;import javax.swing.*;public class InterruptibleSocketTest&#123; public static void main(String[] args) &#123; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; JFrame frame = new InterruptibleSocketFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); &#125; &#125;); &#125;&#125;class InterruptibleSocketFrame extends JFrame&#123; public InterruptibleSocketFrame() &#123; setSize(WIDTH, HEIGHT); setTitle("InterruptibleSocketTest"); JPanel northPanel = new JPanel(); add(northPanel, BorderLayout.NORTH); messages = new JTextArea(); add(new JScrollPane(messages)); interruptibleButton = new JButton("Interruptible"); blockingButton = new JButton("Blocking"); northPanel.add(interruptibleButton); northPanel.add(blockingButton); interruptibleButton.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; interruptibleButton.setEnabled(false); blockingButton.setEnabled(false); cancelButton.setEnabled(true); connectThread = new Thread(new Runnable() &#123; public void run() &#123; try &#123; connectInterruptibly(); &#125; catch (IOException e) &#123; messages.append("\nInterruptibleSocketTest.connectInterruptibly: " + e); &#125; &#125; &#125;); connectThread.start(); &#125; &#125;); blockingButton.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; interruptibleButton.setEnabled(false); blockingButton.setEnabled(false); cancelButton.setEnabled(true); connectThread = new Thread(new Runnable() &#123; public void run() &#123; try &#123; connectBlocking(); &#125; catch (IOException e) &#123; messages.append("\nInterruptibleSocketTest.connectBlocking: " + e); &#125; &#125; &#125;); connectThread.start(); &#125; &#125;); cancelButton = new JButton("Cancel"); cancelButton.setEnabled(false); northPanel.add(cancelButton); cancelButton.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; connectThread.interrupt(); cancelButton.setEnabled(false); &#125; &#125;); server = new TestServer(); new Thread(server).start(); &#125; public void connectInterruptibly() throws IOException &#123; messages.append("Interruptible:\n"); SocketChannel channel = SocketChannel.open(new InetSocketAddress("localhost", 8189)); try &#123; in = new Scanner(channel); while (!Thread.currentThread().isInterrupted()) &#123; messages.append("Reading "); if (in.hasNextLine()) &#123; String line = in.nextLine(); messages.append(line); messages.append("\n"); &#125; &#125; &#125; finally &#123; channel.close(); EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; messages.append("Channel closed\n"); interruptibleButton.setEnabled(true); blockingButton.setEnabled(true); &#125; &#125;); &#125; &#125; public void connectBlocking() throws IOException &#123; messages.append("Blocking:\n"); Socket sock = new Socket("localhost", 8189); try &#123; in = new Scanner(sock.getInputStream()); while (!Thread.currentThread().isInterrupted()) &#123; messages.append("Reading "); if (in.hasNextLine()) &#123; String line = in.nextLine(); messages.append(line); messages.append("\n"); &#125; &#125; &#125; finally &#123; sock.close(); EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; messages.append("Socket closed\n"); interruptibleButton.setEnabled(true); blockingButton.setEnabled(true); &#125; &#125;); &#125; &#125; class TestServer implements Runnable &#123; public void run() &#123; try &#123; ServerSocket s = new ServerSocket(8189); while (true) &#123; Socket incoming = s.accept(); Runnable r = new TestServerHandler(incoming); Thread t = new Thread(r); t.start(); &#125; &#125; catch (IOException e) &#123; messages.append("\nTestServer.run: " + e); &#125; &#125; &#125; class TestServerHandler implements Runnable &#123; /** * Constructs a handler. * @param i the incoming socket */ public TestServerHandler(Socket i) &#123; incoming = i; &#125; public void run() &#123; try &#123; OutputStream outStream = incoming.getOutputStream(); PrintWriter out = new PrintWriter(outStream, true /* autoFlush */); while (counter &lt; 100) &#123; counter++; if (counter &lt;= 10) out.println(counter); Thread.sleep(100); &#125; incoming.close(); messages.append("Closing server\n"); &#125; catch (Exception e) &#123; messages.append("\nTestServerHandler.run: " + e); &#125; &#125; private Socket incoming; private int counter; &#125; private Scanner in; private JButton interruptibleButton; private JButton blockingButton; private JButton cancelButton; private JTextArea messages; private TestServer server; private Thread connectThread; public static final int WIDTH = 300; public static final int HEIGHT = 300;&#125; 未解决问题：阻塞套接字未能正常工作，可能与其底层实现机制有关]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实现服务器]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用ServerSocket类实现服务器下面的代码使用了ServerSocket类建立一个套接字 123456789101112ServerSocket s = new ServerSocket(8189);//服务器占用的端口号为8189Socket incoming = s.accept();//等待客户端的连接，每有一个客户端连接到该服务器，都会获得一个Socket对象InputStream inStream = incoming.getInputStream();OutputStream outStream = incoming.getOutputStream();//获得相应的输入输出流，它的输出为客户端的输入，它的输入为客户端的输出Scanner in=new Scanner(inStream);PrintWriter out = new PrintWriter(out);//实例化相应的读入器和写入器，方便操作out.println("hello! Enter BYB to exit");//给客户端的问候信息incoming.close()//记得关闭套接字 每一个服务器程序，都不间断的执行下面这个循环操作 通过输入数据流从客户端接收一个命令 解码这个命令 收集客户端所请求的信息 通过输出数据流发送信息给客户端 示例代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.net.*;import java.util.*;public class EchoServer&#123; public static void main(String[] args) &#123; try &#123; // establish server socket ServerSocket s = new ServerSocket(8189); // wait for client connection Socket incoming = s.accept(); try &#123; InputStream inStream = incoming.getInputStream(); OutputStream outStream = incoming.getOutputStream(); Scanner in = new Scanner(inStream); PrintWriter out = new PrintWriter(outStream, true /* autoFlush */); out.println("Hello! Enter BYE to exit."); // echo client input boolean done = false; while (!done &amp;&amp; in.hasNextLine()) &#123; String line = in.nextLine(); out.println("Echo: " + line); if (line.trim().equals("BYE")) done = true; &#125; &#125; finally &#123; incoming.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 为多个客户端服务为了实现同时为多个客户端服务，服务器应该有类似以下代码的循环操作 123456while(true)&#123; Socket incoming = s.accept(); Runnable r= new ThreadedEchoHander(incoming); Thread t = new Thread(r); t.start();&#125; ThreadedEchoHander类实现了Runnable接口，而且在它的run方法中包含了与客户端循环通信的代码。 123456789101112class ThreadedEchoHandler implements Runnable&#123; public void run()&#123; try&#123; InputStream inStream=incoming.getInputStream(); OutputStream outStream = incoming.getOutputStream(); process input and send response incoming.close(); &#125;catch(IOException e)&#123; handle exception &#125; &#125;&#125; 每一个连接都会启动一个新的线程，因而多个客户端就可以同时连接到服务器了。 示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.*;import java.net.*;import java.util.*;public class ThreadedEchoServer&#123; public static void main(String[] args ) &#123; try &#123; int i = 1; ServerSocket s = new ServerSocket(8189); while (true) &#123; Socket incoming = s.accept(); System.out.println("Spawning " + i); Runnable r = new ThreadedEchoHandler(incoming); Thread t = new Thread(r); t.start(); i++; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ThreadedEchoHandler implements Runnable&#123; public ThreadedEchoHandler(Socket i) &#123; incoming = i; &#125; public void run() &#123; try &#123; try &#123; InputStream inStream = incoming.getInputStream(); OutputStream outStream = incoming.getOutputStream(); Scanner in = new Scanner(inStream); PrintWriter out = new PrintWriter(outStream, true /* autoFlush */); out.println( "Hello! Enter BYE to exit." ); // echo client input boolean done = false; while (!done &amp;&amp; in.hasNextLine()) &#123; String line = in.nextLine(); out.println("Echo: " + line); if (line.trim().equals("BYE")) done = true; &#125; &#125; finally &#123; incoming.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private Socket incoming;&#125; 半关闭半关闭：套接字连接的一端可以终止其输出，同时仍旧可以接受来自另一端的数据。 可以通过关闭一个套接字的输出流来表示发送给服务器的请求数据已经结束，但是必须保持输入流处于打开状态。 123456789101112Socket socket=new Socket(host,port);Scanner in=new Scanner(socket.getInputStream());PrintWriter writer=new PrintWriter(socket.getOutputStream());writer.print(...);writer.flush();socket.shutdownOutput();//已经进入半关闭//现在还可以读数据while(in.hasNextLine()!=null)&#123; String line=in.nextLine();......&#125;socket.close();]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连接到服务器]]></title>
    <url>%2F2019%2F07%2F24%2F%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[bad guy 使用套接字socketSocket类非常简单易用，因为java技术隐藏了建立网络连接和通过连接发送数据的复杂过程。实际上，java.net包提供的编程接口和操作文件时所使用的接口基本相同。 下面是一个示例程序，该程序只适用于非常简单的服务器 123456789101112131415161718192021222324252627282930313233343536import java.io.*;import java.net.*;import java.util.*;public class SocketTest&#123; public static void main(String[] args) &#123; try &#123; Socket s = new Socket("time-A.timefreq.bldrdoc.gov", 13); //通过一个url和端口号打开一个套接字，如果失败它将抛出一个UnknownHostException异常 //如果有其他问题，它将抛出一个IOException异常 try &#123; InputStream inStream = s.getInputStream(); //一旦套接字被打开，getInputStream()方法将返回一个InputStream对象 //可以使用这个对象实例化Scanner打印输出 Scanner in = new Scanner(inStream); while (in.hasNextLine()) &#123; String line = in.nextLine(); System.out.println(line); &#125; &#125; finally &#123; s.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 套接字超时在可以访问数据之前从套接字读取信息时，读操作将会被阻塞。如果此时主机不可达，那么应用将要等待很长时间，由于底层操作系统的限制而最终会导致超时。 可以调用Socket类的setSoTimeout方法设置这个超时值，若在指定时间内数据依然不能被访问，就会抛出SocketTimeoutException异常。 1234567try&#123; Socket s=new Socket(...); s.setSoTimeout(10000); InputStream in = s.getInputStream();&#125;catch(InterruptedIOException e)&#123; //&#125; 还可以对获取连接的时间加以控制，这样就不会使获取连接的过程一直阻塞 123Socket s = new Socket();//先构建一个无连接的套接字s.connect(new InetSocketAddress(host,port),timeout); 因特网地址如果需要在主机名和因特网地址之间进行转换，可以使用InetAddress类如果主机操作系统支持IPv6格式的因特网地址，java.net包也可以获取的到 1234InetAddress address = InetAddress.getByName("www.baidu.com");//返回的InetAddress对象封装了一个4字节的序列byte[] addressBytes=address.getAddress();//得到地址序列 一些访问量较大的主机名常会对应于多个因特网地址，以实现负载均衡。当访问主机时，其因特网地址将从这三者中随机产生。可以通过调用getAllByName方法获得所有主机 123InetAddress[] address= InetAddress.getAllByName(host);InetAddress addressLocal=InetAddress.getLocalHost();//获得本机IP 示例程序如下： 1234567891011121314151617181920212223242526import java.net.*;public class InetAddressTest&#123; public static void main(String[] args) &#123; try &#123; if (args.length &gt; 0) &#123; String host = args[0]; InetAddress[] addresses = InetAddress.getAllByName(host); for (InetAddress a : addresses) System.out.println(a); &#125; else &#123; InetAddress localHostAddress = InetAddress.getLocalHost(); System.out.println(localHostAddress); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xml(三)]]></title>
    <url>%2F2019%2F07%2F23%2Fxml-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[friendships XSL转换XSL转换（XSLT）机制可是指定将XML文档转换为其他格式的规则，例如，纯文本、XHTML或其他任何XML格式。XSLT通常用来将一个机器可读的XML格式转译为另一种机器可读的XML格式，或者将XML转译为适于人类阅读的标识格式 你需要提供XSLT样式表，它描述了XML文档向某种其他格式转换的规则。XSLT处理器处理这个文档，并产生想要的输出 加入我们想要把下面这个XML文件： 123456789101112&lt;staff&gt; &lt;employee&gt; &lt;name&gt;Carl Cracker&lt;/name&gt; &lt;salary&gt;75000&lt;/salary&gt; &lt;hiredate year="1987" month="12" day="15" /&gt; &lt;/employee&gt; &lt;employee&gt; &lt;name&gt;Harry Hacker&lt;/name&gt; &lt;salary&gt;50000&lt;/salary&gt; &lt;hiredate year="1989" month="3" day="1" /&gt; &lt;/employee&gt;&lt;/staff&gt; 转换成下面的表格： 12345678&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;Carl Cracker&lt;/td&gt;&lt;td&gt;$75000&lt;/td&gt;&lt;td&gt;1987-12-15&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Harry Hacker&lt;/td&gt;&lt;td&gt;$50000&lt;/td&gt;&lt;td&gt;1989-3-1&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 具有转换模板的样式表形式如下： 12345678&lt;?xml version="1.0" encoding="utf-8"&gt;&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt; &lt;xsl:output method="html"/&gt; template1 template2&lt;/xsl:stylesheet&gt; 上例的输出设定为html，还可以设置为xml和text 下面是个典型的模板，match属性的值是一个XPath表达式。该模板表名，每当看到一个XPath集/staff/employee中的一个节点时，做以下动作： 产生字符串&lt; tr&gt; 对于要处理的子元素继续应用模板。 当处理完所有子元素后，产生字符串&lt; /tr&gt; 123&lt;xsl:template match="/staff/employee"&gt; &lt;tr&gt;&lt;xsl:apply-templates/&gt;&lt;/tr&gt;&lt;/xsl:template&gt; XSLT处理器由检查根元素开始其处理过程。每当一个节点匹配某个模板时，就回应应用这个模板（如果匹配多个，就会使用最佳匹配的那个）。如果没有匹配的模板，处理器就执行默认操作。对于文本节点，默认操作是把它的内容包含到输出中去。对于元素，默认操作是不产生输出的，但会继续处理其子节点。 如果想把属性值复制到输出中去，就不得不再做稍微复杂点的操作了。下面是一个例子，当处理hiredate节点时。该模板会产生： 字符串&lt; td&gt; year属性的值 一个连字符 month属性的值 一个连字符 day属性值 一个连字符 字符串&lt; /td&gt; xsl:value-of语句用于计算节点集的字符串值。节点集由select属性的XPath值设定。在这个例子中，该路径是相对于当前处理节点的相对路径。节点集通过连接各个节点的字符串值被转换成一个字符串。属性节点的字符串值就是它的值，文本节点的字符串值是它的内容，元素节点的字符串值是它子节点的字符串值的连接（没有属性） 12345&lt;xsl:template match="/staff/employee/hiredate"&gt; &lt;td&gt;&lt;xsl:value-of select="@year"/&gt;- &lt;xsl:value-of select="@month"/&gt;- &lt;xsl:value-of select="@day"/&gt;&lt;/td&gt;&lt;/xsl:template&gt; 下面这段代码将与上面相同的XML文件转换成text文件。position()函数输出在当前节点在父节点中的索引顺序。 1234567891011121314151617181920&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt; &lt;xsl:output method="text"/&gt; &lt;xsl:template match="/staff/employee"&gt;employee. &lt;xsl:value-of select="position()"/&gt;.name= &lt;xsl:value-of select="name/text()"/&gt;employee. &lt;xsl:value-of select="position()"/&gt;.salary= &lt;xsl:value-of select="salary/text()"/&gt;employee. &lt;xsl:value-of select="position()"/&gt;.hiredate= &lt;xsl:value-of select="hiredate/@year"/&gt;- &lt;xsl:value-of select="hiredate/@month"/&gt;- &lt;xsl:value-of select="hiredate/@day"/&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; java中的代码实现可以使用以下代码框架： 12345File styleSheet=new File(fileName);//样式表文件StreamSource styleSource = new StreamSource(styleSheet);Transformer t= TransformerFactory.newInstance(). newTransformer(styleSource);t.transform(source,result); transform方法的参数是Source和Result接口的实现类的对象。Source接口有3个实现类： DOMSource SAXSource StreamSource 可以根据一个文件、流、阅读器、URL或来自DOM树节点的DOMSource来构建一个StreamSource。 用于转换器的SAXSource可以根据XML阅读器（实现XMLReader接口的类）构建 12345t.transform(new SAXSource( new EmployeeReader(),new InputSource( new FileInputStream(fileName))),result);//fileName(根据XML阅读器（EmployeeReader类）转换)-&gt;xml文件//(根据前面指定的styleSheet样式表)-&gt;result 当然大多数的时候都已经有了xml格式的输入数据，只要在一个StreamSource对象上调用transform方法即可 1t.transform(new StreamSource(file),result); 其转换结果是Result接口实现类的一个对象： DOMResult SAXResult StreamResult 如果要把结果存储到DOM树中，请使用DocumentBuilder产生一个新的文档节点，并将其包装到DOMResult中： 12Document doc = builder.newDocument();t.transform(source,new DOMResult(doc)); 如果要把结果保存为文件，可以使用StreamResult将输出保存为文件 1t.transform(source,new StreamResult(file)); 示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package transformtest;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.StringTokenizer;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.sax.SAXSource;import javax.xml.transform.stream.StreamResult;import javax.xml.transform.stream.StreamSource;import org.xml.sax.ContentHandler;import org.xml.sax.DTDHandler;import org.xml.sax.EntityResolver;import org.xml.sax.ErrorHandler;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.XMLReader;import org.xml.sax.helpers.AttributesImpl;public class TransformTest&#123; public static void main(String[] args) throws Exception &#123; String filename; if (args.length &gt; 0) filename = args[0]; else filename = "makehtml.xsl"; File styleSheet = new File(filename); StreamSource styleSource = new StreamSource(styleSheet); Transformer t = TransformerFactory.newInstance().newTransformer(styleSource); t.setOutputProperty(OutputKeys.INDENT, "yes"); t.setOutputProperty(OutputKeys.METHOD, "xml"); t.setOutputProperty("&#123;http://xml.apache.org/xslt&#125;indent-amount", "2"); t.transform(new SAXSource(new EmployeeReader(), new InputSource(new FileInputStream( "employee.dat"))), new StreamResult(System.out)); &#125;&#125;class EmployeeReader implements XMLReader&#123; public void parse(InputSource source) throws IOException, SAXException &#123; InputStream stream = source.getByteStream(); BufferedReader in = new BufferedReader(new InputStreamReader(stream)); String rootElement = "staff"; AttributesImpl atts = new AttributesImpl(); if (handler == null) throw new SAXException("No content handler"); handler.startDocument(); handler.startElement("", rootElement, rootElement, atts); String line; while ((line = in.readLine()) != null) &#123; handler.startElement("", "employee", "employee", atts); StringTokenizer t = new StringTokenizer(line, "|"); handler.startElement("", "name", "name", atts); String s = t.nextToken(); handler.characters(s.toCharArray(), 0, s.length()); handler.endElement("", "name", "name"); handler.startElement("", "salary", "salary", atts); s = t.nextToken(); handler.characters(s.toCharArray(), 0, s.length()); handler.endElement("", "salary", "salary"); atts.addAttribute("", "year", "year", "CDATA", t.nextToken()); atts.addAttribute("", "month", "month", "CDATA", t.nextToken()); atts.addAttribute("", "day", "day", "CDATA", t.nextToken()); handler.startElement("", "hiredate", "hiredate", atts); handler.endElement("", "hiredate", "hiredate"); atts.clear(); handler.endElement("", "employee", "employee"); &#125; handler.endElement("", rootElement, rootElement); handler.endDocument(); &#125; public void setContentHandler(ContentHandler newValue) &#123; handler = newValue; &#125; public ContentHandler getContentHandler() &#123; return handler; &#125; // the following methods are just do-nothing implementations public void parse(String systemId) throws IOException, SAXException &#123; &#125; public void setErrorHandler(ErrorHandler handler) &#123; &#125; public ErrorHandler getErrorHandler() &#123; return null; &#125; public void setDTDHandler(DTDHandler handler) &#123; &#125; public DTDHandler getDTDHandler() &#123; return null; &#125; public void setEntityResolver(EntityResolver resolver) &#123; &#125; public EntityResolver getEntityResolver() &#123; return null; &#125; public void setProperty(String name, Object value) &#123; &#125; public Object getProperty(String name) &#123; return null; &#125; public void setFeature(String name, boolean value) &#123; &#125; public boolean getFeature(String name) &#123; return false; &#125; private ContentHandler handler;&#125; 测试结果如下：]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java访问控制]]></title>
    <url>%2F2019%2F07%2F23%2Fjava%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[java所有的的访问修饰符控制的都是直接访问]]></content>
      <categories>
        <category>我眼中的java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[static关键字的使用(一)]]></title>
    <url>%2F2019%2F07%2F23%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[static方法与构造静态方法一般不能调用任何非静态成员，却能调用非静态的构造 12345678910111213141516171819202122232425262728293031323334353637383940414243package staticmethod;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub StaticMethod aMethod=StaticMethod.newInstance(); System.out.println(aMethod); &#125;&#125;class StaticMethod&#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public static StaticMethod newInstance()&#123; return new StaticMethod(1, "hhh"); &#125; private StaticMethod()&#123; &#125; @Override public String toString() &#123; return "StaticMethod [id=" + id + ", name=" + name + "]"; &#125; private StaticMethod(int id, String name) &#123; super(); this.id = id; this.name = name; &#125;&#125; static方法与接口接口中可以包含static方法了，但是必须有方法的实现，且调用方式有严格限制 123456public interface TestInter &#123;void printme();static void print_s()&#123;System.out.println("print in static method in interface");&#125;&#125; 必须像下面这样调用 1TestInter.print_s();]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>对象与类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xml(二)]]></title>
    <url>%2F2019%2F07%2F23%2Fxml-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[刚刚好——薛之谦 StAX解析器StAX解析器是一种“拉解析器（pull parser）”，与安装事件处理器不同，你只需要使用下面的基本循环来迭代所有事件： 1234567InputStream in = url.openStream();XMLInputFactory factory=XMLInputFactory.newInstance();XMLStreamReader parser=factory.createXMLStreamReader(in);wehile(parser.hasNext())&#123; int event =parser.next(); Call parser methods to obtain event details&#125; 例如，在解析下面的片段时 1234&lt;font&gt; &lt;name&gt;Helvetica&lt;/name&gt; &lt;size units="pt"&gt;78&lt;/size&gt;&lt;/font&gt; 解析器将产生下面的事件： START_ELEMENT,元素名：font CHARACTERS，内容：空白字符 START_ELEMENT，元素名：name CHARACTERS，内容：Helvetica END_ELEMENT，元素名：name CHARACTERS，内容：空白字符 START_ELEMENT，元素名：size CHARACTERS，内容：78 END_ELEMENT，元素名：size CHARACTERS，内容：空白字符 END_ELEMENT，元素名：font 默认情况下命名空间是使能的，你可以通过修改下面的工厂来使其无效： 1factory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE,false); 示例程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041package staxtest;import java.io.InputStream;import java.net.URL;import javax.xml.stream.XMLInputFactory;import javax.xml.stream.XMLStreamConstants;import javax.xml.stream.XMLStreamReader;public class StAXTest&#123; public static void main(String[] args) throws Exception &#123; String urlString; if (args.length == 0) &#123; urlString = "https://bigengzhe.github.io/atom.xml"; System.out.println("Using " + urlString); &#125; else urlString = args[0]; URL url = new URL(urlString); InputStream in = url.openStream();//用URL来初始化一个输入流 XMLInputFactory factory = XMLInputFactory.newInstance(); XMLStreamReader parser = factory.createXMLStreamReader(in);//用输入流来初始化解析器 while (parser.hasNext()) &#123; int event = parser.next();//返回的常量代表相应的解析事件， if (event == XMLStreamConstants.START_ELEMENT) &#123; if (parser.getLocalName().equals("link")) &#123; String href = parser.getAttributeValue(null, "href"); //当前事件是START_ELEMENT时，获取给定属性的值。 //若第一个参数为空，则不检查命名空间 if (href != null) System.out.println(href); &#125; &#125; &#125; &#125;&#125; 结果截图： 生成XML文档​ 现在你已经知道怎样编写读取XML的java程序了，下面让我们开始介绍他的反向过程。当然你可以选择直接通过一系列print调用，打印出各元素，属性和文本内容来编写XML文件，但其实有更好的办法。 DOM/XSLT方式可以使用文档的内容构建一棵DOM树，然后写出该树的所有内容。步骤如下： 通过调用DocumentBuilder类的newDocument方法得到一个空文档 1Document doc = builder.newDocument(); 使用Document类的createElement可以构建文档里的元素 12 Element rootElement= doc.createElement(rootName);Element childElement=doc.createElement(childName); 使用createTextNode方法可以构建文本节点 1Text textNode=doc.createTextNode(textcontents); 使用以下方法可以给文档加上根元素，给父元素加上子节点 123doc.appendChild(rootElement);rootElement.appendChild(childElement);childElement.appendChild(textNode); 如果要设置元素属性的话： 1rootElement.setAttribute(name,value); 使用XSTL将DOM树写入到输出流： 123456789File f = chooser.getSelectedFile();//得到输出流目标目标文件Transformer t = TransformerFactory.newInstance().newTransformer();t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, "http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd");t.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "-//W3C//DTD SVG 20000802//EN");t.setOutputProperty(OutputKeys.INDENT, "yes");t.setOutputProperty(OutputKeys.METHOD, "xml");t.setOutputProperty("&#123;http://xml.apache.org/xslt&#125;indent-amount", "2");t.transform(new DOMSource(doc), new StreamResult(new FileOutputStream(f))); 使用StAX写XML文档SaAX API使我们可以直接将XML树写出，不用构建DOM树，这需要从某个OutputStream中构建一个XMLstreamWriter。步骤如下 先得到一个XMLstreamWriter对象 12XMLOutputFactory factory=XMLOutputFactory.newInstance();XMLStreamWriter writer=factory.createXMLStreamWriter(out);//out是个输出流对象 产生XML文件头 1writer.writeStartDocument(); 添加元素 1writer.writeStartElement(name); 添加属性 1writer.writeAttribute(name,value); 现在，可以再次通过第三步来添加新的子节点，或者通过下面的语句写出字符 1writer.writeCharacters(text); 在添加完所有的子节点后，调用下面的方法会使当前元素被关闭 1writer.writeEndElement(); 写出没有子节点的元素（如：&lt; img …/&gt;)，可以使用下面的调用 1writer.writeEmptyElement(name); 最后在文档的结尾调用： 1writer.writeEndDocument(); 与使用DOM/XSLT方式一样，我们不必担心属性值和字符数据中的转义字符，但是，我们仍旧有可能会产生非良构的XML，例如具有多个根节点的文档。并且，StAX当前的版本还没有任何对产生缩进输出的支持 示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304package xmlwritetest;import java.awt.Color;import java.awt.EventQueue;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Rectangle;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.geom.Rectangle2D;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.Random;import javax.swing.JComponent;import javax.swing.JFileChooser;import javax.swing.JFrame;import javax.swing.JMenu;import javax.swing.JMenuBar;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.stream.XMLOutputFactory;import javax.xml.stream.XMLStreamException;import javax.xml.stream.XMLStreamWriter;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import org.w3c.dom.Document;import org.w3c.dom.Element;public class XMLWriteTest&#123; public static void main(String[] args) &#123; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; XMLWriteFrame frame = new XMLWriteFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); &#125; &#125;); &#125;&#125;/** * A frame with a component for showing a modern drawing. */class XMLWriteFrame extends JFrame&#123; public XMLWriteFrame() &#123; setTitle("XMLWriteTest"); setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT); chooser = new JFileChooser(); // add component to frame comp = new RectangleComponent(); add(comp); // set up menu bar JMenuBar menuBar = new JMenuBar(); setJMenuBar(menuBar); JMenu menu = new JMenu("File"); menuBar.add(menu); JMenuItem newItem = new JMenuItem("New"); menu.add(newItem); newItem.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; comp.newDrawing(); &#125; &#125;); JMenuItem saveItem = new JMenuItem("Save with DOM/XSLT"); menu.add(saveItem); saveItem.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; try &#123; saveDocument(); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(XMLWriteFrame.this, e.toString()); &#125; &#125; &#125;); JMenuItem saveStAXItem = new JMenuItem("Save with StAX"); menu.add(saveStAXItem); saveStAXItem.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; try &#123; saveStAX(); &#125; catch (Exception e) &#123; JOptionPane.showMessageDialog(XMLWriteFrame.this, e.toString()); &#125; &#125; &#125;); JMenuItem exitItem = new JMenuItem("Exit"); menu.add(exitItem); exitItem.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; System.exit(0); &#125; &#125;); &#125; /** * Saves the drawing in SVG format, using DOM/XSLT */ public void saveDocument() throws TransformerException, IOException &#123; if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) return; File f = chooser.getSelectedFile(); Document doc = comp.buildDocument(); Transformer t = TransformerFactory.newInstance().newTransformer(); t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, "http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd"); t.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "-//W3C//DTD SVG 20000802//EN"); t.setOutputProperty(OutputKeys.INDENT, "yes"); t.setOutputProperty(OutputKeys.METHOD, "xml"); t.setOutputProperty("&#123;http://xml.apache.org/xslt&#125;indent-amount", "2"); t.transform(new DOMSource(doc), new StreamResult(new FileOutputStream(f))); &#125; /** * Saves the drawing in SVG format, using StAX */ public void saveStAX() throws FileNotFoundException, XMLStreamException &#123; if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) return; File f = chooser.getSelectedFile(); XMLOutputFactory factory = XMLOutputFactory.newInstance(); XMLStreamWriter writer = factory.createXMLStreamWriter(new FileOutputStream(f)); comp.writeDocument(writer); writer.close(); &#125; public static final int DEFAULT_WIDTH = 300; public static final int DEFAULT_HEIGHT = 200; private RectangleComponent comp; private JFileChooser chooser;&#125;/** * A component that shows a set of colored rectangles */class RectangleComponent extends JComponent&#123; public RectangleComponent() &#123; rects = new ArrayList&lt;Rectangle2D&gt;(); colors = new ArrayList&lt;Color&gt;(); generator = new Random(); DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try &#123; builder = factory.newDocumentBuilder(); &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; &#125; /** * Create a new random drawing. */ public void newDrawing() &#123; int n = 10 + generator.nextInt(20); rects.clear(); colors.clear(); for (int i = 1; i &lt;= n; i++) &#123; int x = generator.nextInt(getWidth()); int y = generator.nextInt(getHeight()); int width = generator.nextInt(getWidth() - x); int height = generator.nextInt(getHeight() - y); rects.add(new Rectangle(x, y, width, height)); int r = generator.nextInt(256); int g = generator.nextInt(256); int b = generator.nextInt(256); colors.add(new Color(r, g, b)); &#125; repaint(); &#125; public void paintComponent(Graphics g) &#123; if (rects.size() == 0) newDrawing(); Graphics2D g2 = (Graphics2D) g; // draw all rectangles for (int i = 0; i &lt; rects.size(); i++) &#123; g2.setPaint(colors.get(i)); g2.fill(rects.get(i)); &#125; &#125; /** * Creates an SVG document of the current drawing. * @return the DOM tree of the SVG document */ public Document buildDocument() &#123; Document doc = builder.newDocument(); Element svgElement = doc.createElement("svg"); doc.appendChild(svgElement); svgElement.setAttribute("width", "" + getWidth()); svgElement.setAttribute("height", "" + getHeight()); for (int i = 0; i &lt; rects.size(); i++) &#123; Color c = colors.get(i); Rectangle2D r = rects.get(i); Element rectElement = doc.createElement("rect"); rectElement.setAttribute("x", "" + r.getX()); rectElement.setAttribute("y", "" + r.getY()); rectElement.setAttribute("width", "" + r.getWidth()); rectElement.setAttribute("height", "" + r.getHeight()); rectElement.setAttribute("fill", colorToString(c)); svgElement.appendChild(rectElement); &#125; return doc; &#125; /** * Writers an SVG document of the current drawing. * @param writer the document destination */ public void writeDocument(XMLStreamWriter writer) throws XMLStreamException &#123; writer.writeStartDocument(); writer.writeDTD("&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 20000802//EN\" " + "\"http://www.w3.org/TR/2000/CR-SVG-20000802/DTD/svg-20000802.dtd\"&gt;"); writer.writeStartElement("svg"); writer.writeAttribute("width", "" + getWidth()); writer.writeAttribute("height", "" + getHeight()); for (int i = 0; i &lt; rects.size(); i++) &#123; Color c = colors.get(i); Rectangle2D r = rects.get(i); writer.writeEmptyElement("rect"); writer.writeAttribute("x", "" + r.getX()); writer.writeAttribute("y", "" + r.getY()); writer.writeAttribute("width", "" + r.getWidth()); writer.writeAttribute("height", "" + r.getHeight()); writer.writeAttribute("fill", colorToString(c)); &#125; writer.writeEndDocument(); // closes svg element &#125; /** * Converts a color to a hex value. * @param c a color * @return a string of the form #rrggbb */ private static String colorToString(Color c) &#123; StringBuffer buffer = new StringBuffer(); buffer.append(Integer.toHexString(c.getRGB() &amp; 0xFFFFFF)); while (buffer.length() &lt; 6) buffer.insert(0, '0'); buffer.insert(0, '#'); return buffer.toString(); &#125; private ArrayList&lt;Rectangle2D&gt; rects; private ArrayList&lt;Color&gt; colors; private Random generator; private DocumentBuilder builder;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XPath]]></title>
    <url>%2F2019%2F07%2F22%2FXPath%2F</url>
    <content type="text"><![CDATA[缘分一道桥 如果要定位某个XML文档中的一段特定信息，DOM解析方式过于麻烦，此时可用XPath XPath可以描述XML文档中的一组节点 例如: /gridbag/row 描述了根元素gridbag的子元素中所有的row元素。 可以用[]操作符来选择特定元素：/gridbag/row[1] 这表示的是第一行（索引号从1开始）。 使用@操作符可以得到属性值。 XPath表达式：/gridbag/row[1]/cell[1]/@anchor 描述了第一行第一个单元格的anchor属性。 XPath表达式：/gridbag/row/cell/@anchor 描述了作为根元素gridbag子元素的那些行元素中所有单元格的anchor属性节点。 以下是代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243package xpath;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.xpath.XPath;import javax.xml.xpath.XPathConstants;import javax.xml.xpath.XPathFactory;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;public class Main &#123; public static void main(String[] args) throws Exception&#123; // TODO Auto-generated method stub File f=new File("fontdialog.xml"); DocumentBuilderFactory dfactory=DocumentBuilderFactory.newInstance();//DocumentBuilderFactory实例化 DocumentBuilder builder=dfactory.newDocumentBuilder(); Document doc=builder.parse(f);//用DOM方式指定XML文档对象 XPathFactory factory=XPathFactory.newInstance(); XPath path=factory.newXPath(); NodeList nodes=(NodeList)path.evaluate("/gridbag/row", doc,XPathConstants.NODESET);//获取/gridbag/row所有元素 System.out.println(nodes.getLength()); System.out.println((Number)path .evaluate("count(/gridbag/row)", doc, XPathConstants.NUMBER));//计算row节点的数量，注意row后面不要带斜杠 Node node=(Node)path.evaluate("/gridbag/row[1]/cell[1]/bean/class", doc,XPathConstants.NODE);//获取特定子元素 String author=(String)path.evaluate("/gridbag/row[1]/cell[1]/@anchor", doc);//获取特定元素属性值 System.out.println(node.getNodeName()); System.out.println(author); Node node1=(Node)path.evaluate("/gridbag/row[1]", doc,XPathConstants.NODE);//获取特定子元素 String node2=path.evaluate("/row/cell[1]/@author", node1); System.out.println("从任意一个节点开始,如"+node1.getNodeName()+"结果："+node2);//测试失败！！ &#125;&#125; 输出结果： 意外情况（方法已过时）： 感觉xml相关类及接口置放位置很是混乱：]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[致自己]]></title>
    <url>%2F2019%2F07%2F22%2F%E8%87%B4%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[水星记——郭顶： ​ 这些天晚上在看谷川俊太郎的《一个人生活》，感触很多。谷川俊太郎是日本著名的诗人和散文家，这本书是他在年近古稀之时写的一个散文集，写的朴实随意，却又不失有趣。 ​ 其中《翘望春天的书信》篇中引用的永赖清子的的一首诗给了我极其深刻的印象： 一直在原野之上 因我一直急于求成 致使其他毫无建树 我为了什么而如此地心急火燎呢？ 思虑再三&nbsp;&nbsp;&nbsp;&nbsp;我只是急着规划自己成长的脚步 ——明明那脚步永不会停歇—— 而且，明明只会让我舍弃很多很多的美好——​ 那么我急于求成了吗？大概是有的吧，俩三月内要看完很多书，还有很多视频要看，因此顾此失彼，荒了很多其他自己曾经立志要坚持的东西，可是还能怎么办呢，马上要开始秋招了，那些东西是找到一个好的实习所必备的知识。同学们都打算考研，在努力备战。比起有人说考研是一个人的修行，现在来说却是用在我身上更为合适。凯歌不在这已经好几天了，从早到晚都是一个人，果然一个人的生活。 ​ 说起来这两天学习有点松懈，总是不想学习，内心给了自己一个寻找自我的借口不断放纵，安逸是毁灭的前兆，坚持努力吧，趁自己还有充裕的时间，趁自己还没有被其他琐事所烦扰，仔细一想，这不就是我租房的意义所在？如果不想开学后一无所获，不想承受家里的压力，自己给姐姐和父母许下的承诺，Keep fighting。开学后就要写实训课的设计了，开学前还要花点时间想想写啥以及如何写的问题，自己还想想在项目里用上框架啥的，不知是否现实（目测应该可以），等等，我突然有个大胆的想法，要是把我的个人博客写成一个设计岂不两全其美（窃喜），哈哈哈哈。 用户访问网站要先要求登录或注册，之后用其用户id实例化一个hexo项目文件夹； 利用java更改其配置文件（直接copy效果更好）； 用户写博客的话可以直接上传Markdown文件，然后服务器加载其文件，重新生成相应文件 增加点赞和取消点赞功能 增加评论和删除评论功能 增加搜索文章（仅限标题）功能 可达鸭眉头一挑，发现问题确实不难:smile:]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些小细节]]></title>
    <url>%2F2019%2F07%2F21%2F%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[导入jar包时看清哪些类在哪些包下，可以参考一下API（入伏能找到的话），确认这个类不在所有可运行的包下之后再去网上找jar包]]></content>
      <tags>
        <tag>踩坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown编辑器Typora]]></title>
    <url>%2F2019%2F07%2F21%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8Typora%2F</url>
    <content type="text"><![CDATA[Typora快捷键目录 windows快捷键： 给代码块设置快捷键: Mac中的快捷键： 图片： 表情 数学公式 HTML 行内嵌数学符号 下标 高亮 参考： windows快捷键：# 无序列表：输入-之后输入空格 有序列表：输入数字+“.”之后输入空格 任务列表：-[空格]空格 文字 标题：ctrl+数字 表格：ctrl+t 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 代码块：ctrl+alt+f 加粗：ctrl+b 倾斜：ctrl+i 下划线：ctrl+u 删除线：alt+shift+5 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 插入链接：ctrl + k 搜索最近打开的文件：Ctrl+k 给代码块设置快捷键:#偏好设置-&gt;打开高级设置-&gt;conf.user.json文件 12345678"keyBinding": &#123; // for example: // "Always on Top": "Ctrl+Shift+P" "Always on Top": "Ctrl+Shift+P", "Code Fences": "Ctrl+Shift+F", "Ordered List":"Ctrl+Alt+o", "Unordered List": "Ctrl+Alt+u" &#125;, Code Fences 代码块 Ordered List 数字有序列表 Unordered List 无序列表 转自：hongda]]></content>
      <categories>
        <category>其他软件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[html的常用标签]]></title>
    <url>%2F2019%2F07%2F21%2Fhtml%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[在html中插入音频]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xml(一)]]></title>
    <url>%2F2019%2F07%2F21%2Fxml-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[xml概述 xml标准文档的极佳版本 xml是一种能表示层次结构的标记语言，比属性文件的平面表结构更灵活，它与html较为类似 区别如下： 1.xml是大小写敏感的，如， 1&lt;H1&gt; 和 1&lt;h1&gt; 是不同的xml标签 2.在xml中，只有一个标签而无相应的尾标签的元素必须以/结尾，比如 1&lt;img src="" /&gt; ，这样，解析器就不必查找 1&lt;/img&gt; 标签了。 3.在xml中，属性值必须用引号括起来，在html中，引号是可有可无的，如 1&lt;applet code="" width=300 height=400&gt; 对html来说是合法的，但对xml来说不合法。 4.在html中属性可以没有值，如， 1&lt;input type="radio" name="hhh" value="hhh" checked&gt; ，在xml中所有属性都必须有值。 xml文档的结构 xml应当以一个文档头开始，如： 1&lt;?xml version="1.0" encoding="UTF-8"?&gt; 文档头之后通常是文档类型定义，如: 1&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DAD Web Application 2.2//EN" "http://java.sun.com/j2ee/dtds/web-app_2_2.dtd"&gt; 最后xml文档的正文包含根元素，根元素包含一些其他的元素。如： 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration...&gt;&lt;configuration&gt; &lt;title&gt; &lt;font&gt; &lt;name&gt;Helvetica&lt;/name&gt; &lt;size&gt;36&lt;/size&gt; &lt;/font&gt; &lt;/title&gt;&lt;/configuration&gt; 元素可以有子元素、文本或者两者皆有（在设计xml文档时，最好使元素要么包含子元素，要么包含文本，应该避免以下情况：在xml规范中，这叫做混合式内容，避免了混合式内容可以简化简化解析过程。） 1234&lt;font&gt; Helvetica &lt;size&gt;35&lt;/size&gt;&lt;/font&gt; 属性只应在修改值的解释时使用，而不是指定值时使用。 元素和文档是xml文档的“主要支撑要素”，以下是一些标记说明 字符引用的形式是&amp;#十进制值，或者&amp;#x十六进制值，如字符e可以用下面两种形式表示： &amp;#233； &amp;#xD9； 实体引用的形式是&name;。下面这些实体引用：&amp;lt；&amp;gt；&amp;amp；&amp;quot；&amp;apos；分别表示&lt;，&gt;，&amp;，’，…等字符，可以在DTD中定义其他的实体引用。 CDATA部分用&lt;![CDATA[和]]&gt;来限定其界限。他们是字符数据的一种特殊形式。你可以使用它们来包含那些含有&lt;，&gt;，&amp;之类字符的字符串，而不必将它们解释为标记，例如： 1&lt;![CDATA[&lt; &amp; &gt; are myfavourate delimiters]]&gt; CDATA部分不能包含字符串]]&gt;。使用这一特性时要特别注意。它常用来当做将传统数据偷偷纳入XML文档的一个后门。 处理指令（processing instruction）是那些专门在处理xml文档的应用程序中使用的指令，它们将用&lt;?和?&gt;来限定其界限，例如： 1&lt;?xml-stylesheet href="mystyle.css" type="text/css"?&gt; 每个xml都以下面这个处理指令开头： &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 注释用&lt;!– 和–!&gt;来限定其界限：&lt;!– 这是一个注释 –!&gt; 解析xml文档一、基于文档对象模型（DOM）的树形解析器 DOM解析器对于实现我们的大多数目的来说都很容易，不过用它生成树结构会消耗大量内存。JDK中自己包含的有DOM解析器，我们可以直接拿来用 下面的代码使用了DOM解析器解析了相关的xml文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package domtree;import java.io.File;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.w3c.dom.Text;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();//DocumentBuilderFactory实例化 File file=new File("src/web.xml");//classpath下的一个xml文件 try &#123; DocumentBuilder builder=factory.newDocumentBuilder(); Document doc=builder.parse(file);//选择输入源，可以是文件或者是URL: //Document doc=builder.parse(url);或者是一个输入流： //Document doc=builder.parse(inputStream); //如果使用输入流作为输入源，当这个源的初始化对象是那些相对于文档位置定位的文件时 //解析器将无法定位，但是可以通过安装一个“实体分解器（entity resolver）” //来解决这个问题 Element root =doc.getDocumentElement();//获得根节点 treeParser("",root);//递归的访问元素节点 //System.out.println("hhhh\thhhh");测试tab &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void treeParser(String tab,Element element)&#123; System.out.println(tab+element.getTagName());//打印元素节点名称 NodeList childrens=element.getChildNodes();//获得元素节点的所有子节点 if(childrens.getLength()&gt;1)&#123;//若元素节点的子节点还有元素节点 for(int i=0;i&lt;childrens.getLength();i++)&#123;//遍历element的所有子节点 Node child=childrens.item(i); if(child instanceof Element)&#123;//若其是元素节点，则递归的访问其子节点 treeParser(tab+"\t",(Element)child); &#125; &#125; &#125;else&#123;//element元素节点下只剩数据，则输出其数据 System.out.print(tab+"\t"); System.out.println( ((Text)element.getFirstChild()) .getData().trim());// &#125; System.out.println(tab+element.getTagName());//再次输出元素节点名称 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;!-- 配置 org.springframework.web.filter.HiddenHttpMethodFilter: 可以把 POST 请求转为 DELETE 或 POST 请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置 DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置 DispatcherServlet 的一个初始化参数: 配置 SpringMVC 配置文件的位置和名称 --&gt; &lt;!-- 实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认的. 默认的配置文件为: /WEB-INF/&lt;servlet-name&gt;-servlet.xml --&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 二、基于xml简单API的（SAX）的流机制解析器（事件回调方式） SAX解析器在解析XML输入的控件时就报告事件，但不会以任何方式存储文档。 在使用SAX解析器时，需要一个处理器来定义不同的解析器事件的事件动作。他们都实现了ContentHandler接口。ContentHandler接口定义了几个回调方法。最常用的如下 startElement和endElement在每当遇到起始或终止标签是调用。 characters每当遇到字符数据时调用。 startDocument和endDocument分别在文档开始和结束时各调用一次。 例如解析以下片段时： 1234&lt;font&gt; &lt;name&gt;Helvetica&lt;/name&gt; &lt;size units="pt"&gt;36&lt;/size&gt;&lt;/font&gt; 解析器会有以下调用： startElement，元素名：font startElement，元素名：name characters，内容：Helvetica endElement，元素名：name startElement，元素名：size，属性：units=“pt” characters，内容：36 endElement，元素名：size endElement，元素名：font 示例程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package saxtest;import java.io.InputStream;import java.net.URL;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import org.xml.sax.Attributes;import org.xml.sax.helpers.DefaultHandler;public class SAXTest&#123; public static void main(String[] args) throws Exception &#123; String url; if (args.length == 0) &#123; url = "http://www.w3c.org"; System.out.println("Using " + url); &#125; else url = args[0]; DefaultHandler handler = new DefaultHandler()//用匿名内部类实例化处理器 &#123; public void startElement(String namespaceURI, String lname, String qname, Attributes attrs) &#123; //namespaceURL:命名空间 //lname：本地名 //qname：以alias：localname形式表示的限定名 //attrs：元素属性集合 if (lname.equals("a") &amp;&amp; attrs != null) &#123; for (int i = 0; i &lt; attrs.getLength(); i++)//对属性集合遍历 &#123; String aname = attrs.getLocalName(i);//获得属性的本地名 if (aname.equals("href")) System.out.println(attrs.getValue(i)); //打印输出属性值 &#125; &#125; &#125; &#125;; SAXParserFactory factory = SAXParserFactory.newInstance(); factory.setNamespaceAware(true);//设置命名空间可用 SAXParser saxParser = factory.newSAXParser();//获取SAX解析器 InputStream in = new URL(url).openStream();//获得输入流 saxParser.parse(in, handler); //根据传入的输入流（可以是文件，URL等）和处理器来处理xml文件 //处理器必须是DefaultHandler的子类，DefaultHandler类为以下接口定义了空的方法： //ContentHandler，DTDHandler，EntityResolver，ErrorHandler &#125;&#125;]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[绘制图表软件visio]]></title>
    <url>%2F2019%2F07%2F20%2F%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E8%BD%AF%E4%BB%B6visio%2F</url>
    <content type="text"><![CDATA[visio常用快捷键 复制 按ctrl+拖动 水平/垂直复制 按ctrl+shift+ 拖动（水平/垂直） 水平/垂直移动 按shift+拖动 放大 ctrl+滚轮 键拖动幕布 ctrl+alt+鼠标右 水平滚动画布 shift+滚轮 选择工具 ctrl+1 文字工具 ctrl+2 连接线 ctrl+3 形状工具 ctrl+8 文本（加粗/斜体/删除线） ctrl+b/i/u 字体变大/小 ctrl+shift+,/. 矩形→正方形/椭圆→圆形/直线→水平/垂直或45°线 shift 组合/取消组合 ctrl+g/ctrl+shift+u 字体下标/上标 ctrl+＝/ctrl+shift+＝ 保存 F12Visio 使用小技巧 选中图形，左下角可以调出大小和位置。 取消箭头自动连接 进去visio视图-&gt;视觉帮助 右下角点三角形把当前活动的中的对齐粘附选项全部取消掉。 鼠标按住尺规的边缘往外拉，会拉出一条绘图辅助线，按del键就会消失，而且选中这条线，按ctrl+L会旋转90°。选粘附到参考线。当拖动图形靠近辅助线时，将锁定图形位置。 选择对齐方式时，是以第一个被选中的图形为基准。左对齐：以第一个图形的左边框为基准线对齐；其他类似。 连接线上添加文字——在连接线上双击鼠标左键，即可添加文字。添加完毕后，按住文字中间的黄色菱形，课任意拖放文字的位置。 搜索形状的搜索栏很好用，你可以在里面找到同一类型不同样式的图形。比如搜索‘连接器’，就会出现上百个不同样式的连接器。 移动线条端点：按住Ctrl键拖动线条端点 转自：https://blog.csdn.net/sinat_20311715/article/details/80858859 去掉绘图背景右击图形， 选择格式，再点里面的填充 选择”图案颜色”的对应的下拉菜单。选择“无”，点击确定，再看，图形形状就变成透明的了， 绘图图片输出步骤如下： https://jingyan.baidu.com/article/48b558e336a8a17f38c09a9e.html 线段点对齐如下所示，鼠标悬浮不动，按上键或下键，可以微调线段的位置]]></content>
      <categories>
        <category>其他软件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java流家族]]></title>
    <url>%2F2019%2F07%2F20%2Fjava%E6%B5%81%E5%AE%B6%E6%97%8F%2F</url>
    <content type="text"><![CDATA[java流家族类及接口继承结构如下： 字节流： 字符流：]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>io</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DataOutputStream二进制输入输出时存在的问题]]></title>
    <url>%2F2019%2F07%2F20%2FDataOutputStream%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>java学习笔记</category>
        <category>io</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次踩坑记录：hexo配置文件package]]></title>
    <url>%2F2019%2F07%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%9Ahexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6package%2F</url>
    <content type="text"><![CDATA[哎呀花了我大半天时间终于把这个bug给解决了，都是当时我乱改配置文件惹的祸，发誓再也不乱改配置文件了。。。 ​ 之前发现的问题是我的hexo不能正常显示我的Markdown文本内嵌的html标签，到网上好一阵百度，终于证明不是hexo的锅，没错，这锅应该我来背，，这配置文件改的太久了，都过去了好几个月了，早忘了当时自己改了啥了， ​ 记一下解决办法吧，虽然还没意识到问题的本质，解决如下： ​ 重新初始化一个hexo项目文件夹，进行隔离测试（这是个好办法，出现不明原因bug时要记得经常使用），不断地将之前的配置拿到新文件夹中测试，先是对主题测试，证明不是主题配置的问题，之后再对_config.xml文件进行测试，结果没问题，而后在对hexo主目录下的package.json文件内节点进行逐项测试（而我比较懒，就没有逐项），证明是此文件的配置项的问题后，之后将老站点的资源文件及相关有效配置迁移到新站点]]></content>
      <categories>
        <category>前端</category>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>踩坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立志做一个勤奋的笔耕者]]></title>
    <url>%2F2019%2F07%2F19%2F%E7%AB%8B%E5%BF%97%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8B%A4%E5%A5%8B%E7%9A%84%E7%AC%94%E8%80%95%E8%80%85%2F</url>
    <content type="text"><![CDATA[​ 花了五六个小时的时间，利用hexo框架总算是把我的个人博客给搭建起来了，实属不易呀，并且完成了在GitHub上的静态发布。 ​ 搭建个人博客对程序员来说是挺重要的一件事，可以在个人博客上写一些个人的学习笔记，知识总结，加深自己对相关知识的理解，还有一些踩坑记录，避免自己再次踩坑:grin:，以后还可以在上面放一些生活随笔。下搭建个人博客决心的过程有点艰难，本来很早的时候就有过搭建个人博客的想法，可是那个时候感觉，写个人博客的都是技术大拿，自己作为一个程序猿小透明，不会也没有必要去写个人博客，感觉写了也没人看，这么长时间经历了蛮多事，同学们大都考研了，自己找实习的过程中又屡遭碰壁，感觉自己的基础知识极度不扎实，有些知识点说明白也明白点，可但往深处一问，就有啥都不会了，更让自己无法接受的是那个说自己基础不扎实的面试官还是自己的同龄。幸而有个学长给自己指明了现阶段的方向，终于决定暑假恶补自己的java的基础知识，外加数据库（mysql）和开发框架（spring全家桶），无奈学习效率不尽如人意，感觉看过教学视频后再在总结为一篇博客效果会好点。 博客更新计划如下： 1.框架部分准备一日多更 2.java部分一日一更 3.其他博文周更 具体步骤参见个人博客的搭建。 ​]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为你的hexo添加表情]]></title>
    <url>%2F2019%2F07%2F19%2F%E4%B8%BA%E4%BD%A0%E7%9A%84hexo%E6%B7%BB%E5%8A%A0%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客的搭建]]></title>
    <url>%2F2019%2F07%2F19%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[我采用的是hexo博客框架 搭建过程需要一下步骤： 1.安装git 2.安装Nodejs 3.安装hexo（包括以上两项都可以去官网下载，直接安装，没毛病） 4.需要在github上注册一个账号，已有可自动忽略 生成hexo目录及更改hexo的配置文件以上算是搭建完成了，之后需要新建一个文件夹你的git usename（或者其他），cd进入此文件夹，执行： hexo init 会默认在当前文件夹下生成hexo的目录，目录及命令介绍详见hexo文档，详细阅读之后能了解hexo的目录架构，及工作方式，同时更改_config.yml的配置 修改主题在_config.yml配置文件中有个theme字段中可更改主题，next挺好用的，详细配置参见https://www.jianshu.com/p/b75146d016e6及next文档http://theme-next.iissnan.com/getting-started.html]]></content>
      <categories>
        <category>前端</category>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat导入源码]]></title>
    <url>%2F2019%2F07%2F19%2FTomcat%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java与编码]]></title>
    <url>%2F2019%2F07%2F19%2Fjava%E4%B8%8E%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[utf-16编码​ 先解释一下utf-16编码： ​ 原文链接：https://blog.csdn.net/wusj3/article/details/88641084 java与utf-16​ 从jdk 5.0开始。代码点是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，代码点采用十六进制书写，并加上前缀U+，例如U+0041就是字母A的代码点。Unicode的代码点可以分为十七个代码级别。第一个代码级别被称为基本的多语言级别，代码点从U+0000到U+FFFF，其中包含了经典的Unicode代码；其余的十六个附加级别代码点从U+10000到U+10FFFF，其中包含了一些辅助字符，辅助字符一般采用一对连续的的代码单元表示 在java中，char类型用UTF-16编码描述一个代码单元]]></content>
      <categories>
        <category>我眼中的java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo中next的其他配置]]></title>
    <url>%2F2019%2F07%2F19%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%98%BE%E7%A4%BA%E6%91%98%E8%A6%81%E5%92%8C%E9%98%85%E8%AF%BB%E5%8E%9F%E6%96%87%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[1.Hexo博客NexT主题下显示摘要和阅读原文按钮转自https://blog.csdn.net/mqdxiaoxiao/article/details/93263923 2. 我可以设置这一句的颜色哈哈]]></content>
      <categories>
        <category>前端</category>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>操作与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
